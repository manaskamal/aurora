; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?image_handle@@3PEAXEA				; image_handle
PUBLIC	?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA	; system_table
PUBLIC	?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA	; boot_service
PUBLIC	?runtime_service@@3PEAUEFI_RUNTIME_SERVICES@@EA	; runtime_service
PUBLIC	?framebuffer_address@@3PEAIEA			; framebuffer_address
PUBLIC	?x_res@@3IA					; x_res
PUBLIC	?y_res@@3IA					; y_res
PUBLIC	?fb_size@@3_KA					; fb_size
PUBLIC	?pixels_per_line@@3IA				; pixels_per_line
PUBLIC	?recent_file_size@@3_KA				; recent_file_size
_BSS	SEGMENT
?image_handle@@3PEAXEA DQ 01H DUP (?)			; image_handle
?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA DQ 01H DUP (?)	; system_table
?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA DQ 01H DUP (?) ; boot_service
?runtime_service@@3PEAUEFI_RUNTIME_SERVICES@@EA DQ 01H DUP (?) ; runtime_service
?framebuffer_address@@3PEAIEA DQ 01H DUP (?)		; framebuffer_address
?x_res@@3IA DD	01H DUP (?)				; x_res
?y_res@@3IA DD	01H DUP (?)				; y_res
?fb_size@@3_KA DQ 01H DUP (?)				; fb_size
?pixels_per_line@@3IA DD 01H DUP (?)			; pixels_per_line
	ALIGN	8

?recent_file_size@@3_KA DQ 01H DUP (?)			; recent_file_size
_BSS	ENDS
CONST	SEGMENT
$SG13476 DB	'[', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 'd', 00H, 'r', 00H
	DB	']', 00H, ':', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 'b', 00H, 'o'
	DB	00H, 'o', 00H, 't', 00H, ' ', 00H, 'v', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 0dH, 00H, 0aH, 00H, 00H
	DB	00H
	ORG $+2
$SG13481 DB	'[', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 'd', 00H, 'r', 00H
	DB	']', 00H, ':', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'f', 00H
	DB	'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 0dH, 00H, 0aH
	DB	00H, 00H, 00H
	ORG $+10
$SG13488 DB	'[', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 'd', 00H, 'r', 00H
	DB	']', 00H, ':', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, ' ', 00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'r', 00H, 'y', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, '!', 00H, ' ', 00H, 0dH, 00H
	DB	0aH, 00H, 00H, 00H
	ORG $+8
$SG13494 DB	'[', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 'd', 00H, 'r', 00H
	DB	']', 00H, ':', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG13507 DB	'[', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 'i', 00H, 'b', 00H
	DB	']', 00H, ':', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' '
	DB	00H, 'g', 00H, 'r', 00H, 'a', 00H, 'p', 00H, 'h', 00H, 'i', 00H
	DB	'c', 00H, 's', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 'p'
	DB	00H, 'u', 00H, 't', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H
	DB	't', 00H, 'o', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG13526 DB	'[', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 'd', 00H, 'r', 00H
	DB	']', 00H, ':', 00H, 'g', 00H, 'r', 00H, 'a', 00H, 'p', 00H, 'h'
	DB	00H, 'i', 00H, 'c', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd'
	DB	00H, ' ', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
CONST	ENDS
PUBLIC	?aulib_initialize@@YAHPEAXPEAUEFI_SYSTEM_TABLE@@@Z ; aulib_initialize
PUBLIC	?aulib_initialize_console@@YAHXZ		; aulib_initialize_console
PUBLIC	?aulib_set_text_attrib@@YAXHH@Z			; aulib_set_text_attrib
PUBLIC	?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ ; aulib_get_system_table
PUBLIC	?aulib_allocate@@YAPEAX_K@Z			; aulib_allocate
PUBLIC	?aulib_load_file@@YAPEAEPEA_W@Z			; aulib_load_file
PUBLIC	?aulib_query_gop@@YA_KII@Z			; aulib_query_gop
PUBLIC	?aulib_set_graphics_mode@@YAH_K@Z		; aulib_set_graphics_mode
PUBLIC	?aulib_get_fb_address@@YAPEAIXZ			; aulib_get_fb_address
PUBLIC	?aulib_get_x_resolution@@YAIXZ			; aulib_get_x_resolution
PUBLIC	?aulib_get_y_resolution@@YAIXZ			; aulib_get_y_resolution
PUBLIC	?aulib_get_fb_size@@YA_KXZ			; aulib_get_fb_size
PUBLIC	?aulib_get_pixels_per_line@@YAIXZ		; aulib_get_pixels_per_line
PUBLIC	?aulib_free@@YAXPEAX@Z				; aulib_free
PUBLIC	?aulib_get_acpi_pointer@@YAPEAXXZ		; aulib_get_acpi_pointer
PUBLIC	?aulib_get_recent_file_size@@YA_KXZ		; aulib_get_recent_file_size
PUBLIC	?aulib_copy_mem@@YAXPEAX0_K@Z			; aulib_copy_mem
PUBLIC	?guid_match@@YA_NUGUID@@0@Z			; guid_match
EXTRN	?printf@@YAHPEA_WZZ:PROC			; printf
pdata	SEGMENT
$pdata$?aulib_initialize_console@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?aulib_initialize_console@@YAHXZ
$pdata$?aulib_set_text_attrib@@YAXHH@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?aulib_set_text_attrib@@YAXHH@Z
$pdata$?aulib_allocate@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$?aulib_allocate@@YAPEAX_K@Z
$pdata$?aulib_load_file@@YAPEAEPEA_W@Z DD imagerel $LN7
	DD	imagerel $LN7+663
	DD	imagerel $unwind$?aulib_load_file@@YAPEAEPEA_W@Z
$pdata$?aulib_query_gop@@YA_KII@Z DD imagerel $LN8
	DD	imagerel $LN8+258
	DD	imagerel $unwind$?aulib_query_gop@@YA_KII@Z
$pdata$?aulib_set_graphics_mode@@YAH_K@Z DD imagerel $LN4
	DD	imagerel $LN4+469
	DD	imagerel $unwind$?aulib_set_graphics_mode@@YAH_K@Z
$pdata$?aulib_free@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?aulib_free@@YAXPEAX@Z
$pdata$?aulib_get_acpi_pointer@@YAPEAXXZ DD imagerel $LN7
	DD	imagerel $LN7+256
	DD	imagerel $unwind$?aulib_get_acpi_pointer@@YAPEAXXZ
$pdata$?aulib_copy_mem@@YAXPEAX0_K@Z DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$?aulib_copy_mem@@YAXPEAX0_K@Z
$pdata$?guid_match@@YA_NUGUID@@0@Z DD imagerel $LN10
	DD	imagerel $LN10+186
	DD	imagerel $unwind$?guid_match@@YA_NUGUID@@0@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?aulib_initialize_console@@YAHXZ DD 010401H
	DD	04204H
$unwind$?aulib_set_text_attrib@@YAXHH@Z DD 010c01H
	DD	0620cH
$unwind$?aulib_allocate@@YAPEAX_K@Z DD 010901H
	DD	06209H
$unwind$?aulib_load_file@@YAPEAEPEA_W@Z DD 020c01H
	DD	037010cH
$unwind$?aulib_query_gop@@YA_KII@Z DD 010c01H
	DD	0c20cH
$unwind$?aulib_set_graphics_mode@@YAH_K@Z DD 020c01H
	DD	011010cH
$unwind$?aulib_free@@YAXPEAX@Z DD 010901H
	DD	04209H
$unwind$?aulib_get_acpi_pointer@@YAPEAXXZ DD 030701H
	DD	07003e207H
	DD	06002H
$unwind$?aulib_copy_mem@@YAXPEAX0_K@Z DD 011301H
	DD	04213H
$unwind$?guid_match@@YA_NUGUID@@0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
first_part_good$ = 0
i$1 = 4
tv77 = 8
guid1$ = 32
guid2$ = 40
?guid_match@@YA_NUGUID@@0@Z PROC			; guid_match

; 249  : bool guid_match(EFI_GUID guid1, EFI_GUID guid2) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 250  : 	bool first_part_good = (guid1.Data1 == guid2.Data1 && guid1.Data2 == guid2.Data2 &&
; 251  : 		guid1.Data3 == guid2.Data3);

	mov	rax, QWORD PTR guid1$[rsp]
	mov	rcx, QWORD PTR guid2$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN8@guid_match
	mov	rax, QWORD PTR guid1$[rsp]
	movzx	eax, WORD PTR [rax+4]
	mov	rcx, QWORD PTR guid2$[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	cmp	eax, ecx
	jne	SHORT $LN8@guid_match
	mov	rax, QWORD PTR guid1$[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR guid2$[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	cmp	eax, ecx
	jne	SHORT $LN8@guid_match
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN9@guid_match
$LN8@guid_match:
	mov	DWORD PTR tv77[rsp], 0
$LN9@guid_match:
	movzx	eax, BYTE PTR tv77[rsp]
	mov	BYTE PTR first_part_good$[rsp], al

; 252  : 
; 253  : 	if (!first_part_good) return false;

	movzx	eax, BYTE PTR first_part_good$[rsp]
	test	eax, eax
	jne	SHORT $LN5@guid_match
	xor	al, al
	jmp	SHORT $LN6@guid_match
$LN5@guid_match:

; 254  : 
; 255  : 	for (int i = 0; i < 8; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@guid_match
$LN3@guid_match:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@guid_match:
	cmp	DWORD PTR i$1[rsp], 8
	jge	SHORT $LN2@guid_match

; 256  : 		if (guid1.Data4[i] != guid2.Data4[i]) return false;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR guid1$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+8]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR guid2$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx+8]
	cmp	eax, ecx
	je	SHORT $LN1@guid_match
	xor	al, al
	jmp	SHORT $LN6@guid_match
$LN1@guid_match:

; 257  : 	}

	jmp	SHORT $LN3@guid_match
$LN2@guid_match:

; 258  : 
; 259  : 	return true;

	mov	al, 1
$LN6@guid_match:

; 260  : }

	add	rsp, 24
	ret	0
?guid_match@@YA_NUGUID@@0@Z ENDP			; guid_match
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
dstp$ = 0
srcp$ = 8
tv66 = 16
dst$ = 48
src$ = 56
length$ = 64
?aulib_copy_mem@@YAXPEAX0_K@Z PROC			; aulib_copy_mem

; 280  : void aulib_copy_mem(void* dst, void* src, size_t length){

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 281  : 	uint8_t* dstp = (uint8_t*)dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR dstp$[rsp], rax

; 282  : 	uint8_t* srcp = (uint8_t*)src;

	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR srcp$[rsp], rax
$LN2@aulib_copy:

; 283  : 	while (length--)

	mov	rax, QWORD PTR length$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR length$[rsp]
	dec	rax
	mov	QWORD PTR length$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	je	SHORT $LN1@aulib_copy

; 284  : 		*dstp++ = *srcp++;

	mov	rax, QWORD PTR dstp$[rsp]
	mov	rcx, QWORD PTR srcp$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dstp$[rsp]
	inc	rax
	mov	QWORD PTR dstp$[rsp], rax
	mov	rax, QWORD PTR srcp$[rsp]
	inc	rax
	mov	QWORD PTR srcp$[rsp], rax
	jmp	SHORT $LN2@aulib_copy
$LN1@aulib_copy:

; 285  : }

	add	rsp, 40					; 00000028H
	ret	0
?aulib_copy_mem@@YAXPEAX0_K@Z ENDP			; aulib_copy_mem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
?aulib_get_recent_file_size@@YA_KXZ PROC		; aulib_get_recent_file_size

; 141  : 	return recent_file_size;

	mov	rax, QWORD PTR ?recent_file_size@@3_KA	; recent_file_size

; 142  : }

	ret	0
?aulib_get_recent_file_size@@YA_KXZ ENDP		; aulib_get_recent_file_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
i$1 = 32
config_table$ = 40
xsdp_address$ = 48
acpi_guid$ = 56
$T2 = 80
$T3 = 96
?aulib_get_acpi_pointer@@YAPEAXXZ PROC			; aulib_get_acpi_pointer

; 265  : void* aulib_get_acpi_pointer() {

$LN7:
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H

; 266  : 	EFI_CONFIGURATION_TABLE *config_table = system_table->ConfigurationTable;

	mov	rax, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR config_table$[rsp], rax

; 267  : 	void* xsdp_address = NULL;

	mov	QWORD PTR xsdp_address$[rsp], 0

; 268  : 	EFI_GUID acpi_guid = ACPI_20_TABLE_GUID;

	mov	DWORD PTR acpi_guid$[rsp], -2006390671	; 8868e871H
	mov	eax, 58609				; 0000e4f1H
	mov	WORD PTR acpi_guid$[rsp+4], ax
	mov	eax, 4563				; 000011d3H
	mov	WORD PTR acpi_guid$[rsp+6], ax
	mov	BYTE PTR acpi_guid$[rsp+8], 188		; 000000bcH
	mov	BYTE PTR acpi_guid$[rsp+9], 34		; 00000022H
	mov	BYTE PTR acpi_guid$[rsp+10], 0
	mov	BYTE PTR acpi_guid$[rsp+11], 128	; 00000080H
	mov	BYTE PTR acpi_guid$[rsp+12], 199	; 000000c7H
	mov	BYTE PTR acpi_guid$[rsp+13], 60		; 0000003cH
	mov	BYTE PTR acpi_guid$[rsp+14], 136	; 00000088H
	mov	BYTE PTR acpi_guid$[rsp+15], 129	; 00000081H

; 269  : 	for (unsigned i = 0; i < system_table->NumberOfTableEntries; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@aulib_get_
$LN3@aulib_get_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@aulib_get_:
	mov	eax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	cmp	rax, QWORD PTR [rcx+104]
	jae	SHORT $LN2@aulib_get_

; 270  : 		if (guid_match(acpi_guid, config_table[i].VendorGuid)) {

	mov	eax, DWORD PTR i$1[rsp]
	imul	rax, rax, 24
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdx, QWORD PTR config_table$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax]
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR acpi_guid$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?guid_match@@YA_NUGUID@@0@Z		; guid_match
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@aulib_get_

; 271  : 			xsdp_address = config_table[i].VendorTable;

	mov	eax, DWORD PTR i$1[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR config_table$[rsp]
	mov	rax, QWORD PTR [rcx+rax+16]
	mov	QWORD PTR xsdp_address$[rsp], rax

; 272  : 			return xsdp_address;

	mov	rax, QWORD PTR xsdp_address$[rsp]
	jmp	SHORT $LN5@aulib_get_
$LN1@aulib_get_:

; 273  : 		}
; 274  : 	}

	jmp	$LN3@aulib_get_
$LN2@aulib_get_:
$LN5@aulib_get_:

; 275  : }

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
?aulib_get_acpi_pointer@@YAPEAXXZ ENDP			; aulib_get_acpi_pointer
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
memory$ = 48
?aulib_free@@YAXPEAX@Z PROC				; aulib_free

; 75   : void aulib_free(void* memory) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 76   : 	boot_service->FreePool(memory);

	mov	rcx, QWORD PTR memory$[rsp]
	mov	rax, QWORD PTR ?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA ; boot_service
	call	QWORD PTR [rax+72]

; 77   : }

	add	rsp, 40					; 00000028H
	ret	0
?aulib_free@@YAXPEAX@Z ENDP				; aulib_free
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
?aulib_get_pixels_per_line@@YAIXZ PROC			; aulib_get_pixels_per_line

; 236  : 	return pixels_per_line;

	mov	eax, DWORD PTR ?pixels_per_line@@3IA	; pixels_per_line

; 237  : }

	ret	0
?aulib_get_pixels_per_line@@YAIXZ ENDP			; aulib_get_pixels_per_line
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
?aulib_get_fb_size@@YA_KXZ PROC				; aulib_get_fb_size

; 243  : 	return fb_size;

	mov	rax, QWORD PTR ?fb_size@@3_KA		; fb_size

; 244  : }

	ret	0
?aulib_get_fb_size@@YA_KXZ ENDP				; aulib_get_fb_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
?aulib_get_y_resolution@@YAIXZ PROC			; aulib_get_y_resolution

; 228  : 	return y_res;

	mov	eax, DWORD PTR ?y_res@@3IA		; y_res

; 229  : }

	ret	0
?aulib_get_y_resolution@@YAIXZ ENDP			; aulib_get_y_resolution
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
?aulib_get_x_resolution@@YAIXZ PROC			; aulib_get_x_resolution

; 220  : 	return x_res;

	mov	eax, DWORD PTR ?x_res@@3IA		; x_res

; 221  : }

	ret	0
?aulib_get_x_resolution@@YAIXZ ENDP			; aulib_get_x_resolution
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
?aulib_get_fb_address@@YAPEAIXZ PROC			; aulib_get_fb_address

; 212  : 	return framebuffer_address;

	mov	rax, QWORD PTR ?framebuffer_address@@3PEAIEA ; framebuffer_address

; 213  : }

	ret	0
?aulib_get_fb_address@@YAPEAIXZ ENDP			; aulib_get_fb_address
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
pixel$ = 80
gop$ = 88
status$ = 96
info$ = 104
gopguid$ = 112
mode$ = 144
?aulib_set_graphics_mode@@YAH_K@Z PROC			; aulib_set_graphics_mode

; 176  : int aulib_set_graphics_mode(uint64_t mode) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 177  : 	EFI_STATUS status;
; 178  : 	EFI_GUID gopguid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;

	mov	DWORD PTR gopguid$[rsp], -1874679330	; 9042a9deH
	mov	eax, 9180				; 000023dcH
	mov	WORD PTR gopguid$[rsp+4], ax
	mov	eax, 19000				; 00004a38H
	mov	WORD PTR gopguid$[rsp+6], ax
	mov	BYTE PTR gopguid$[rsp+8], 150		; 00000096H
	mov	BYTE PTR gopguid$[rsp+9], 251		; 000000fbH
	mov	BYTE PTR gopguid$[rsp+10], 122		; 0000007aH
	mov	BYTE PTR gopguid$[rsp+11], 222		; 000000deH
	mov	BYTE PTR gopguid$[rsp+12], 208		; 000000d0H
	mov	BYTE PTR gopguid$[rsp+13], 128		; 00000080H
	mov	BYTE PTR gopguid$[rsp+14], 81		; 00000051H
	mov	BYTE PTR gopguid$[rsp+15], 106		; 0000006aH

; 179  : 	EFI_GRAPHICS_OUTPUT_PROTOCOL *gop = nullptr;

	mov	QWORD PTR gop$[rsp], 0

; 180  : 	status = boot_service->LocateProtocol(&gopguid, NULL, (void**)&gop);

	lea	r8, QWORD PTR gop$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR gopguid$[rsp]
	mov	rax, QWORD PTR ?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA ; boot_service
	call	QWORD PTR [rax+320]
	mov	QWORD PTR status$[rsp], rax

; 181  : 	if (status != EFI_SUCCESS) {

	cmp	QWORD PTR status$[rsp], 0
	je	SHORT $LN1@aulib_set_

; 182  : 		printf(L"[auldr]:graphics not found \r\n");

	lea	rcx, OFFSET FLAT:$SG13526
	call	?printf@@YAHPEA_WZZ			; printf

; 183  : 		return 1;

	mov	eax, 1
	jmp	$LN2@aulib_set_
$LN1@aulib_set_:

; 184  : 	}
; 185  : 	
; 186  : 	/* clear out the serial terminal */
; 187  : 	system_table->ConOut->SetAttribute(system_table->ConOut, EFI_BACKGROUND_BLUE | EFI_WHITE);

	mov	rax, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rax, QWORD PTR [rax+64]
	mov	edx, 31
	mov	rcx, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rcx, QWORD PTR [rcx+64]
	call	QWORD PTR [rax+40]

; 188  : 	system_table->ConOut->SetCursorPosition(system_table->ConOut, 0, 0);

	mov	rax, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rax, QWORD PTR [rax+64]
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rcx, QWORD PTR [rcx+64]
	call	QWORD PTR [rax+56]

; 189  : 
; 190  : 	status = gop->SetMode(gop, mode);

	mov	edx, DWORD PTR mode$[rsp]
	mov	rcx, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR gop$[rsp]
	call	QWORD PTR [rax+8]
	mov	QWORD PTR status$[rsp], rax

; 191  : 	EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *info = gop->Mode->Info;

	mov	rax, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR info$[rsp], rax

; 192  : 	//! clear the screen
; 193  : 	EFI_GRAPHICS_OUTPUT_BLT_PIXEL pixel;
; 194  : 	pixel.Blue = 0;

	mov	BYTE PTR pixel$[rsp], 0

; 195  : 	pixel.Green = 0;

	mov	BYTE PTR pixel$[rsp+1], 0

; 196  : 	pixel.Red = 0;

	mov	BYTE PTR pixel$[rsp+2], 0

; 197  : 
; 198  : 	gop->Blt(gop, &pixel, EfiBltVideoFill, 0, 0, 0, 0, info->HorizontalResolution, info->VerticalResolution, 0);

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	QWORD PTR [rsp+72], 0
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], rcx
	mov	QWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR pixel$[rsp]
	mov	rcx, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR gop$[rsp]
	call	QWORD PTR [rax+16]

; 199  : 	framebuffer_address = (uint32_t*)gop->Mode->FrameBufferBase;

	mov	rax, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR ?framebuffer_address@@3PEAIEA, rax ; framebuffer_address

; 200  : 	fb_size = gop->Mode->FrameBufferSize;

	mov	rax, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR ?fb_size@@3_KA, rax		; fb_size

; 201  : 	x_res = gop->Mode->Info->HorizontalResolution;

	mov	rax, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR ?x_res@@3IA, eax		; x_res

; 202  : 	y_res = gop->Mode->Info->VerticalResolution;

	mov	rax, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR ?y_res@@3IA, eax		; y_res

; 203  : 	pixels_per_line = gop->Mode->Info->PixelsPerScanLine;

	mov	rax, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR ?pixels_per_line@@3IA, eax	; pixels_per_line

; 204  : 	return 0;

	xor	eax, eax
$LN2@aulib_set_:

; 205  : }

	add	rsp, 136				; 00000088H
	ret	0
?aulib_set_graphics_mode@@YAH_K@Z ENDP			; aulib_set_graphics_mode
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
i$1 = 32
gop$ = 40
info$2 = 48
status$ = 56
mode$ = 64
size_of_info$3 = 72
gopguid$ = 80
width$ = 112
height$ = 120
?aulib_query_gop@@YA_KII@Z PROC				; aulib_query_gop

; 151  : uint64_t aulib_query_gop(uint32_t width, uint32_t height) {

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 152  : 
; 153  : 	EFI_GUID gopguid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;

	mov	DWORD PTR gopguid$[rsp], -1874679330	; 9042a9deH
	mov	eax, 9180				; 000023dcH
	mov	WORD PTR gopguid$[rsp+4], ax
	mov	eax, 19000				; 00004a38H
	mov	WORD PTR gopguid$[rsp+6], ax
	mov	BYTE PTR gopguid$[rsp+8], 150		; 00000096H
	mov	BYTE PTR gopguid$[rsp+9], 251		; 000000fbH
	mov	BYTE PTR gopguid$[rsp+10], 122		; 0000007aH
	mov	BYTE PTR gopguid$[rsp+11], 222		; 000000deH
	mov	BYTE PTR gopguid$[rsp+12], 208		; 000000d0H
	mov	BYTE PTR gopguid$[rsp+13], 128		; 00000080H
	mov	BYTE PTR gopguid$[rsp+14], 81		; 00000051H
	mov	BYTE PTR gopguid$[rsp+15], 106		; 0000006aH

; 154  : 	EFI_GRAPHICS_OUTPUT_PROTOCOL *gop = nullptr;

	mov	QWORD PTR gop$[rsp], 0

; 155  : 	EFI_STATUS status;
; 156  : 	status = boot_service->LocateProtocol(&gopguid, NULL, (void**)&gop);

	lea	r8, QWORD PTR gop$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR gopguid$[rsp]
	mov	rax, QWORD PTR ?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA ; boot_service
	call	QWORD PTR [rax+320]
	mov	QWORD PTR status$[rsp], rax

; 157  : 	if (status != EFI_SUCCESS) {

	cmp	QWORD PTR status$[rsp], 0
	je	SHORT $LN5@aulib_quer

; 158  : 		printf(L"[aulib]: failed to locate graphics output protocol");

	lea	rcx, OFFSET FLAT:$SG13507
	call	?printf@@YAHPEA_WZZ			; printf

; 159  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN6@aulib_quer
$LN5@aulib_quer:

; 160  : 	}
; 161  : 
; 162  : 	auto mode = gop->Mode;

	mov	rax, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR mode$[rsp], rax

; 163  : 	for (int i = 0; i < mode->MaxMode; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@aulib_quer
$LN3@aulib_quer:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@aulib_quer:
	mov	rax, QWORD PTR mode$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@aulib_quer

; 164  : 		UINTN size_of_info;
; 165  : 		EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *info;
; 166  : 		gop->QueryMode(gop, i, &size_of_info, &info);

	lea	r9, QWORD PTR info$2[rsp]
	lea	r8, QWORD PTR size_of_info$3[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR gop$[rsp]
	mov	rax, QWORD PTR gop$[rsp]
	call	QWORD PTR [rax]

; 167  : 		if (info->HorizontalResolution == width && info->VerticalResolution == height)

	mov	rax, QWORD PTR info$2[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN1@aulib_quer
	mov	rax, QWORD PTR info$2[rsp]
	mov	ecx, DWORD PTR height$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN1@aulib_quer

; 168  : 			return i;

	movsxd	rax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN6@aulib_quer
$LN1@aulib_quer:

; 169  : 	}

	jmp	SHORT $LN3@aulib_quer
$LN2@aulib_quer:
$LN6@aulib_quer:

; 170  : }

	add	rsp, 104				; 00000068H
	ret	0
?aulib_query_gop@@YA_KII@Z ENDP				; aulib_query_gop
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
status$ = 48
generic_file_info$ = 56
loaded_image_protocol$ = 72
sfs_protocol$ = 88
file$ = 104
read_size$ = 112
data_buffer$ = 120
rootdir$ = 128
file_info$ = 136
bootfs$ = 144
file_info_size$ = 152
loaded_image$ = 160
buffer$ = 176
filename$ = 448
?aulib_load_file@@YAPEAEPEA_W@Z PROC			; aulib_load_file

; 84   : uint8_t* aulib_load_file(wchar_t* filename) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 440				; 000001b8H

; 85   : 	EFI_STATUS status;
; 86   : 
; 87   : 	EFI_GUID loaded_image_protocol = EFI_LOADED_IMAGE_PROTOCOL_GUID;

	mov	DWORD PTR loaded_image_protocol$[rsp], 1528508833 ; 5b1b31a1H
	mov	eax, 38242				; 00009562H
	mov	WORD PTR loaded_image_protocol$[rsp+4], ax
	mov	eax, 4562				; 000011d2H
	mov	WORD PTR loaded_image_protocol$[rsp+6], ax
	mov	BYTE PTR loaded_image_protocol$[rsp+8], 142 ; 0000008eH
	mov	BYTE PTR loaded_image_protocol$[rsp+9], 63 ; 0000003fH
	mov	BYTE PTR loaded_image_protocol$[rsp+10], 0
	mov	BYTE PTR loaded_image_protocol$[rsp+11], 160 ; 000000a0H
	mov	BYTE PTR loaded_image_protocol$[rsp+12], 201 ; 000000c9H
	mov	BYTE PTR loaded_image_protocol$[rsp+13], 105 ; 00000069H
	mov	BYTE PTR loaded_image_protocol$[rsp+14], 114 ; 00000072H
	mov	BYTE PTR loaded_image_protocol$[rsp+15], 59 ; 0000003bH

; 88   : 	EFI_GUID sfs_protocol = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;

	mov	DWORD PTR sfs_protocol$[rsp], -1773249758 ; 964e5b22H
	mov	eax, 25689				; 00006459H
	mov	WORD PTR sfs_protocol$[rsp+4], ax
	mov	eax, 4562				; 000011d2H
	mov	WORD PTR sfs_protocol$[rsp+6], ax
	mov	BYTE PTR sfs_protocol$[rsp+8], 142	; 0000008eH
	mov	BYTE PTR sfs_protocol$[rsp+9], 57	; 00000039H
	mov	BYTE PTR sfs_protocol$[rsp+10], 0
	mov	BYTE PTR sfs_protocol$[rsp+11], 160	; 000000a0H
	mov	BYTE PTR sfs_protocol$[rsp+12], 201	; 000000c9H
	mov	BYTE PTR sfs_protocol$[rsp+13], 105	; 00000069H
	mov	BYTE PTR sfs_protocol$[rsp+14], 114	; 00000072H
	mov	BYTE PTR sfs_protocol$[rsp+15], 59	; 0000003bH

; 89   : 	EFI_GUID generic_file_info = EFI_FILE_INFO_ID;

	mov	DWORD PTR generic_file_info$[rsp], 156724882 ; 09576e92H
	mov	eax, 27967				; 00006d3fH
	mov	WORD PTR generic_file_info$[rsp+4], ax
	mov	eax, 4562				; 000011d2H
	mov	WORD PTR generic_file_info$[rsp+6], ax
	mov	BYTE PTR generic_file_info$[rsp+8], 142	; 0000008eH
	mov	BYTE PTR generic_file_info$[rsp+9], 57	; 00000039H
	mov	BYTE PTR generic_file_info$[rsp+10], 0
	mov	BYTE PTR generic_file_info$[rsp+11], 160 ; 000000a0H
	mov	BYTE PTR generic_file_info$[rsp+12], 201 ; 000000c9H
	mov	BYTE PTR generic_file_info$[rsp+13], 105 ; 00000069H
	mov	BYTE PTR generic_file_info$[rsp+14], 114 ; 00000072H
	mov	BYTE PTR generic_file_info$[rsp+15], 59	; 0000003bH

; 90   : 	EFI_LOADED_IMAGE *loaded_image;
; 91   : 	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL * bootfs;
; 92   : 
; 93   : 	status = boot_service->HandleProtocol(image_handle, &loaded_image_protocol, (void**)&loaded_image);

	lea	r8, QWORD PTR loaded_image$[rsp]
	lea	rdx, QWORD PTR loaded_image_protocol$[rsp]
	mov	rcx, QWORD PTR ?image_handle@@3PEAXEA	; image_handle
	mov	rax, QWORD PTR ?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA ; boot_service
	call	QWORD PTR [rax+152]
	mov	QWORD PTR status$[rsp], rax

; 94   : 	status = boot_service->HandleProtocol(loaded_image->DeviceHandle, &sfs_protocol, (void**)&bootfs);

	lea	r8, QWORD PTR bootfs$[rsp]
	lea	rdx, QWORD PTR sfs_protocol$[rsp]
	mov	rax, QWORD PTR loaded_image$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	mov	rax, QWORD PTR ?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA ; boot_service
	call	QWORD PTR [rax+152]
	mov	QWORD PTR status$[rsp], rax

; 95   : 
; 96   : 	EFI_FILE_PROTOCOL *rootdir;
; 97   : 	status = bootfs->OpenVolume(bootfs, &rootdir);

	lea	rdx, QWORD PTR rootdir$[rsp]
	mov	rcx, QWORD PTR bootfs$[rsp]
	mov	rax, QWORD PTR bootfs$[rsp]
	call	QWORD PTR [rax+8]
	mov	QWORD PTR status$[rsp], rax

; 98   : 	if (status != EFI_SUCCESS) {

	cmp	QWORD PTR status$[rsp], 0
	je	SHORT $LN4@aulib_load

; 99   : 		printf(L"[auldr]: unable to open boot volume \r\n");

	lea	rcx, OFFSET FLAT:$SG13476
	call	?printf@@YAHPEA_WZZ			; printf

; 100  : 		return 0;

	xor	eax, eax
	jmp	$LN5@aulib_load
$LN4@aulib_load:

; 101  : 	}
; 102  : 
; 103  : 	EFI_FILE_PROTOCOL *file;
; 104  : 	status = rootdir->Open(rootdir, &file, (CHAR16*)filename, EFI_FILE_MODE_READ, 0);

	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR filename$[rsp]
	lea	rdx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR rootdir$[rsp]
	mov	rax, QWORD PTR rootdir$[rsp]
	call	QWORD PTR [rax+8]
	mov	QWORD PTR status$[rsp], rax

; 105  : 	if (status == EFI_NOT_FOUND) {

	mov	rax, -9223372036854775794		; 800000000000000eH
	cmp	QWORD PTR status$[rsp], rax
	jne	SHORT $LN3@aulib_load

; 106  : 		printf(L"[auldr]: file not found \r\n");

	lea	rcx, OFFSET FLAT:$SG13481
	call	?printf@@YAHPEA_WZZ			; printf

; 107  : 		return 0;

	xor	eax, eax
	jmp	$LN5@aulib_load
$LN3@aulib_load:

; 108  : 	}
; 109  : 
; 110  : 	uint64_t file_info_size;
; 111  : 	EFI_FILE_INFO *file_info;
; 112  : 
; 113  : 	unsigned char buffer[250];
; 114  : 	file->GetInfo(file, &generic_file_info, &file_info_size, (void**)&buffer);

	lea	r9, QWORD PTR buffer$[rsp]
	lea	r8, QWORD PTR file_info_size$[rsp]
	lea	rdx, QWORD PTR generic_file_info$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rax, QWORD PTR file$[rsp]
	call	QWORD PTR [rax+64]

; 115  : 	status = boot_service->AllocatePool(EfiLoaderData, file_info_size, (void**)&file_info);

	lea	r8, QWORD PTR file_info$[rsp]
	mov	rdx, QWORD PTR file_info_size$[rsp]
	mov	ecx, 2
	mov	rax, QWORD PTR ?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA ; boot_service
	call	QWORD PTR [rax+64]
	mov	QWORD PTR status$[rsp], rax

; 116  : 	if (status != EFI_SUCCESS) {

	cmp	QWORD PTR status$[rsp], 0
	je	SHORT $LN2@aulib_load

; 117  : 		printf(L"[auldr]: failed to allocate memory for file information! \r\n");

	lea	rcx, OFFSET FLAT:$SG13488
	call	?printf@@YAHPEA_WZZ			; printf

; 118  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN5@aulib_load
$LN2@aulib_load:

; 119  : 	}
; 120  : 
; 121  : 	file_info = (EFI_FILE_INFO*)buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR file_info$[rsp], rax

; 122  : 	uint64_t read_size = file_info->FileSize;

	mov	rax, QWORD PTR file_info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR read_size$[rsp], rax

; 123  : 	recent_file_size = read_size;

	mov	rax, QWORD PTR read_size$[rsp]
	mov	QWORD PTR ?recent_file_size@@3_KA, rax	; recent_file_size

; 124  : 	uint8_t* data_buffer = (uint8_t*)aulib_allocate(read_size);

	mov	rcx, QWORD PTR read_size$[rsp]
	call	?aulib_allocate@@YAPEAX_K@Z		; aulib_allocate
	mov	QWORD PTR data_buffer$[rsp], rax

; 125  : 
; 126  : 	status = file->Read(file, &read_size, data_buffer);

	mov	r8, QWORD PTR data_buffer$[rsp]
	lea	rdx, QWORD PTR read_size$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rax, QWORD PTR file$[rsp]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR status$[rsp], rax

; 127  : 
; 128  : 	if (status != EFI_SUCCESS) {

	cmp	QWORD PTR status$[rsp], 0
	je	SHORT $LN1@aulib_load

; 129  : 		printf(L"[auldr]: failed to read file \r\n");

	lea	rcx, OFFSET FLAT:$SG13494
	call	?printf@@YAHPEA_WZZ			; printf

; 130  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN5@aulib_load
$LN1@aulib_load:

; 131  : 	}
; 132  : 
; 133  : 	return data_buffer;	

	mov	rax, QWORD PTR data_buffer$[rsp]
$LN5@aulib_load:

; 134  : }

	add	rsp, 440				; 000001b8H
	ret	0
?aulib_load_file@@YAPEAEPEA_W@Z ENDP			; aulib_load_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
tv70 = 32
buffer$ = 40
memsize$ = 64
?aulib_allocate@@YAPEAX_K@Z PROC			; aulib_allocate

; 66   : void* aulib_allocate(const uint64_t memsize) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 67   : 	void* buffer;
; 68   : 	return (boot_service->AllocatePool(EfiLoaderData, memsize, &buffer) < 0) ? NULL : buffer;

	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR memsize$[rsp]
	mov	ecx, 2
	mov	rax, QWORD PTR ?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA ; boot_service
	call	QWORD PTR [rax+64]
	test	rax, rax
	jae	SHORT $LN3@aulib_allo
	mov	QWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@aulib_allo
$LN3@aulib_allo:
	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR tv70[rsp], rax
$LN4@aulib_allo:
	mov	rax, QWORD PTR tv70[rsp]

; 69   : }

	add	rsp, 56					; 00000038H
	ret	0
?aulib_allocate@@YAPEAX_K@Z ENDP			; aulib_allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ PROC ; aulib_get_system_table

; 59   : 	return system_table;

	mov	rax, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table

; 60   : }

	ret	0
?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ ENDP ; aulib_get_system_table
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
tv66 = 32
f$ = 64
b$ = 72
?aulib_set_text_attrib@@YAXHH@Z PROC			; aulib_set_text_attrib

; 51   : void aulib_set_text_attrib(int f, int b) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 52   : 	system_table->ConOut->SetAttribute(system_table->ConOut, f | b);

	mov	eax, DWORD PTR b$[rsp]
	mov	ecx, DWORD PTR f$[rsp]
	or	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR tv66[rsp], rcx
	mov	rdx, rax
	mov	rax, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rcx, QWORD PTR [rax+64]
	mov	rax, QWORD PTR tv66[rsp]
	call	QWORD PTR [rax+40]

; 53   : }

	add	rsp, 56					; 00000038H
	ret	0
?aulib_set_text_attrib@@YAXHH@Z ENDP			; aulib_set_text_attrib
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
?aulib_initialize_console@@YAHXZ PROC			; aulib_initialize_console

; 40   : int aulib_initialize_console() {

$LN3:
	sub	rsp, 40					; 00000028H

; 41   : 	system_table->ConOut->ClearScreen(system_table->ConOut);

	mov	rax, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rcx, QWORD PTR [rcx+64]
	call	QWORD PTR [rax+48]

; 42   : 	system_table->ConOut->SetAttribute(system_table->ConOut, 0x00 | 0x0F);

	mov	rax, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rax, QWORD PTR [rax+64]
	mov	edx, 15
	mov	rcx, QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA ; system_table
	mov	rcx, QWORD PTR [rcx+64]
	call	QWORD PTR [rax+40]

; 43   : 	return 0;

	xor	eax, eax

; 44   : }

	add	rsp, 40					; 00000028H
	ret	0
?aulib_initialize_console@@YAHXZ ENDP			; aulib_initialize_console
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\aulib.cpp
_TEXT	SEGMENT
image_handle_$ = 8
system_table_$ = 16
?aulib_initialize@@YAHPEAXPEAUEFI_SYSTEM_TABLE@@@Z PROC	; aulib_initialize

; 29   : int aulib_initialize(EFI_HANDLE image_handle_, EFI_SYSTEM_TABLE *system_table_) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 30   : 	system_table = system_table_;

	mov	rax, QWORD PTR system_table_$[rsp]
	mov	QWORD PTR ?system_table@@3PEAUEFI_SYSTEM_TABLE@@EA, rax ; system_table

; 31   : 	boot_service = system_table_->BootServices;

	mov	rax, QWORD PTR system_table_$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR ?boot_service@@3PEAUEFI_BOOT_SERVICES@@EA, rax ; boot_service

; 32   : 	runtime_service = system_table_->RuntimeServices;

	mov	rax, QWORD PTR system_table_$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR ?runtime_service@@3PEAUEFI_RUNTIME_SERVICES@@EA, rax ; runtime_service

; 33   : 	image_handle = image_handle_;

	mov	rax, QWORD PTR image_handle_$[rsp]
	mov	QWORD PTR ?image_handle@@3PEAXEA, rax	; image_handle

; 34   : 	return 0;

	xor	eax, eax

; 35   : }

	ret	0
?aulib_initialize@@YAHPEAXPEAUEFI_SYSTEM_TABLE@@@Z ENDP	; aulib_initialize
_TEXT	ENDS
END
