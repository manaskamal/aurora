; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
chars	DQ	FLAT:$SG13408
_DATA	ENDS
CONST	SEGMENT
$SG13345 DB	'0123456789abcdef', 00H
	ORG $+7
$SG13356 DB	'0123456789ABCDEF', 00H
	ORG $+3
$SG13358 DB	'0X', 00H
	ORG $+1
$SG13359 DB	'0x', 00H
	ORG $+1
$SG13457 DB	'0', 00H
	ORG $+2
$SG13408 DB	'0123456789ABCDEF', 00H
	ORG $+3
$SG13480 DB	'0x', 00H
	ORG $+1
$SG13503 DB	'.', 00H
	ORG $+6
$SG13292 DB	'j', 00H, 'z', 00H, 't', 00H, 00H, 00H
$SG13298 DB	'd', 00H, 'o', 00H, 'u', 00H, 'x', 00H, 'X', 00H, 'c', 00H
	DB	's', 00H, 'p', 00H, 00H, 00H
CONST	ENDS
PUBLIC	?printf@@YAHPEA_WZZ				; printf
PUBLIC	?sztoa@@YAPEAD_KPEADH@Z				; sztoa
PUBLIC	?au_print@@YAXPEBDZZ				; au_print
PUBLIC	?atow@@YAXPEADPEBD@Z				; atow
EXTRN	?aulib_set_text_attrib@@YAXHH@Z:PROC		; aulib_set_text_attrib
EXTRN	?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ:PROC ; aulib_get_system_table
EXTRN	?wstrchr@@YAPEA_WPEA_WH@Z:PROC			; wstrchr
EXTRN	?wstrlen@@YAHPEA_W@Z:PROC			; wstrlen
EXTRN	?strlen@@YA_KPEBD@Z:PROC			; strlen
EXTRN	?to_upper@@YAHH@Z:PROC				; to_upper
EXTRN	?is_digit@@YAHH@Z:PROC				; is_digit
EXTRN	?au_puts@@YAXPEBD@Z:PROC			; au_puts
EXTRN	?au_putc@@YAXD@Z:PROC				; au_putc
pdata	SEGMENT
$pdata$?printf@@YAHPEA_WZZ DD imagerel $LN133
	DD	imagerel $LN133+3225
	DD	imagerel $unwind$?printf@@YAHPEA_WZZ
$pdata$?sztoa@@YAPEAD_KPEADH@Z DD imagerel $LN11
	DD	imagerel $LN11+275
	DD	imagerel $unwind$?sztoa@@YAPEAD_KPEADH@Z
$pdata$?au_print@@YAXPEBDZZ DD imagerel $LN25
	DD	imagerel $LN25+883
	DD	imagerel $unwind$?au_print@@YAXPEBDZZ
pdata	ENDS
xdata	SEGMENT
$unwind$?printf@@YAHPEA_WZZ DD 021b01H
	DD	0123011bH
$unwind$?sztoa@@YAPEAD_KPEADH@Z DD 011301H
	DD	04213H
$unwind$?au_print@@YAXPEBDZZ DD 021b01H
	DD	025011bH
xdata	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\print.cpp
_TEXT	SEGMENT
buf$ = 8
source$ = 16
?atow@@YAXPEADPEBD@Z PROC				; atow

; 372  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
$LN2@atow:

; 373  : 	while (*source != 0)*buf++ = *source++;

	mov	rax, QWORD PTR source$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN1@atow
	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR source$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR buf$[rsp]
	inc	rax
	mov	QWORD PTR buf$[rsp], rax
	mov	rax, QWORD PTR source$[rsp]
	inc	rax
	mov	QWORD PTR source$[rsp], rax
	jmp	SHORT $LN2@atow
$LN1@atow:

; 374  : 	*buf = '\0';

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 0

; 375  : }

	ret	0
?atow@@YAXPEADPEBD@Z ENDP				; atow
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\print.cpp
_TEXT	SEGMENT
args$ = 32
c$1 = 40
buf$2 = 44
buf$3 = 48
i$4 = 56
width$5 = 64
len$6 = 72
i$7 = 80
x$8 = 88
tv134 = 96
x$9 = 104
x$10 = 112
tv133 = 120
buffer$11 = 128
buffer$12 = 208
format$ = 304
?au_print@@YAXPEBDZZ PROC				; au_print

; 306  : {

$LN25:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 296				; 00000128H

; 307  : 	va_list args;
; 308  : 	va_start(args, format);

	lea	rax, QWORD PTR format$[rsp+8]
	mov	QWORD PTR args$[rsp], rax
$LN22@au_print:

; 309  : 	while (*format != '\0') {

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN21@au_print

; 310  : 		if (*format == '%'){

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN20@au_print

; 311  : 			++format;

	mov	rax, QWORD PTR format$[rsp]
	inc	rax
	mov	QWORD PTR format$[rsp], rax

; 312  : 			if (*format == 'd') {

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 100				; 00000064H
	jne	$LN19@au_print

; 313  : 				size_t width = 0;

	mov	QWORD PTR width$5[rsp], 0

; 314  : 				if (format[1] == '.')

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN18@au_print

; 315  : 				{
; 316  : 					for (size_t i = 2; format[i] >= '0' && format[i] <= '9'; ++i)

	mov	QWORD PTR i$4[rsp], 2
	jmp	SHORT $LN17@au_print
$LN16@au_print:
	mov	rax, QWORD PTR i$4[rsp]
	inc	rax
	mov	QWORD PTR i$4[rsp], rax
$LN17@au_print:
	mov	rax, QWORD PTR i$4[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN15@au_print
	mov	rax, QWORD PTR i$4[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN15@au_print

; 317  : 					{
; 318  : 						width *= 10;

	imul	rax, QWORD PTR width$5[rsp], 10
	mov	QWORD PTR width$5[rsp], rax

; 319  : 						width += format[i] - '0';

	mov	rax, QWORD PTR i$4[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cdqe
	mov	rcx, QWORD PTR width$5[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR width$5[rsp], rax

; 320  : 					}

	jmp	SHORT $LN16@au_print
$LN15@au_print:
$LN18@au_print:

; 321  : 				}
; 322  : 				size_t i = va_arg(args, size_t);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR i$7[rsp], rax

; 323  : 				char buffer[sizeof(size_t)* 8 + 1];
; 324  : 				sztoa(i, buffer, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR buffer$11[rsp]
	mov	rcx, QWORD PTR i$7[rsp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 325  : 				size_t len = strlen(buffer);

	lea	rcx, QWORD PTR buffer$11[rsp]
	call	?strlen@@YA_KPEBD@Z			; strlen
	mov	QWORD PTR len$6[rsp], rax
$LN14@au_print:

; 326  : 				while (len++ < width)

	mov	rax, QWORD PTR len$6[rsp]
	mov	QWORD PTR tv133[rsp], rax
	mov	rax, QWORD PTR width$5[rsp]
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR len$6[rsp]
	inc	rax
	mov	QWORD PTR len$6[rsp], rax
	mov	rax, QWORD PTR tv134[rsp]
	cmp	QWORD PTR tv133[rsp], rax
	jae	SHORT $LN13@au_print

; 327  : 					au_puts("0");

	lea	rcx, OFFSET FLAT:$SG13457
	call	?au_puts@@YAXPEBD@Z			; au_puts
	jmp	SHORT $LN14@au_print
$LN13@au_print:

; 328  : 				au_puts(buffer);

	lea	rcx, QWORD PTR buffer$11[rsp]
	call	?au_puts@@YAXPEBD@Z			; au_puts
	jmp	$LN12@au_print
$LN19@au_print:

; 329  : 			}
; 330  : 			else if (*format == 'c'){

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 99					; 00000063H
	jne	SHORT $LN11@au_print

; 331  : 
; 332  : 				char c = va_arg(args, char);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 4
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	movzx	eax, BYTE PTR [rax-4]
	mov	BYTE PTR c$1[rsp], al

; 333  : 				au_putc(c);

	movzx	ecx, BYTE PTR c$1[rsp]
	call	?au_putc@@YAXD@Z			; au_putc
	jmp	$LN10@au_print
$LN11@au_print:

; 334  : 			}
; 335  : 			else if (*format == 'x') {

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN9@au_print

; 336  : 				size_t x = va_arg(args, size_t);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR x$10[rsp], rax

; 337  : 				char buffer[sizeof(size_t)* 8 + 1];
; 338  : 				sztoa(x, buffer, 16);

	mov	r8d, 16
	lea	rdx, QWORD PTR buffer$12[rsp]
	mov	rcx, QWORD PTR x$10[rsp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 339  : 				au_puts("0x");

	lea	rcx, OFFSET FLAT:$SG13480
	call	?au_puts@@YAXPEBD@Z			; au_puts

; 340  : 				au_puts(buffer);

	lea	rcx, QWORD PTR buffer$12[rsp]
	call	?au_puts@@YAXPEBD@Z			; au_puts
	jmp	$LN8@au_print
$LN9@au_print:

; 341  : 			}
; 342  : 			else if (*format == 's') {

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 115				; 00000073H
	jne	SHORT $LN7@au_print

; 343  : 				char* x = va_arg(args, char*);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR x$8[rsp], rax

; 344  : 				au_puts(x);

	mov	rcx, QWORD PTR x$8[rsp]
	call	?au_puts@@YAXPEBD@Z			; au_puts
	jmp	$LN6@au_print
$LN7@au_print:

; 345  : 			}
; 346  : 			else if (*format == 'S'){

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN5@au_print

; 347  : 				char* x = va_arg(args, char*);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR x$9[rsp], rax

; 348  : 				au_puts(x);

	mov	rcx, QWORD PTR x$9[rsp]
	call	?au_puts@@YAXPEBD@Z			; au_puts
	jmp	SHORT $LN4@au_print
$LN5@au_print:

; 349  : 			}
; 350  : 			else if (*format == '%'){

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN3@au_print

; 351  : 				au_puts(".");

	lea	rcx, OFFSET FLAT:$SG13503
	call	?au_puts@@YAXPEBD@Z			; au_puts

; 352  : 			}
; 353  : 			else {

	jmp	SHORT $LN2@au_print
$LN3@au_print:

; 354  : 				char buf[3];
; 355  : 				buf[0] = '%'; buf[1] = *format; buf[2] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR buf$3[rsp+rax], 37		; 00000025H
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR format$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buf$3[rsp+rax], cl
	mov	eax, 1
	imul	rax, rax, 2
	mov	BYTE PTR buf$3[rsp+rax], 0

; 356  : 				au_puts(buf);

	lea	rcx, QWORD PTR buf$3[rsp]
	call	?au_puts@@YAXPEBD@Z			; au_puts
$LN2@au_print:
$LN4@au_print:
$LN6@au_print:
$LN8@au_print:
$LN10@au_print:
$LN12@au_print:

; 357  : 			}
; 358  : 		}
; 359  : 		else

	jmp	SHORT $LN1@au_print
$LN20@au_print:

; 360  : 		{
; 361  : 			char buf[2];
; 362  : 			buf[0] = *format; buf[1] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR format$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buf$2[rsp+rax], cl
	mov	eax, 1
	imul	rax, rax, 1
	mov	BYTE PTR buf$2[rsp+rax], 0

; 363  : 			au_puts(buf);

	lea	rcx, QWORD PTR buf$2[rsp]
	call	?au_puts@@YAXPEBD@Z			; au_puts
$LN1@au_print:

; 364  : 		}
; 365  : 		++format;

	mov	rax, QWORD PTR format$[rsp]
	inc	rax
	mov	QWORD PTR format$[rsp], rax

; 366  : 	}

	jmp	$LN22@au_print
$LN21@au_print:

; 367  : 	va_end(args);
; 368  : }

	add	rsp, 296				; 00000128H
	ret	0
?au_print@@YAXPEBDZZ ENDP				; au_print
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\print.cpp
_TEXT	SEGMENT
tmp$1 = 0
i$ = 4
z$2 = 8
tv67 = 16
tv74 = 24
value$ = 48
str$ = 56
base$ = 64
?sztoa@@YAPEAD_KPEADH@Z PROC				; sztoa

; 286  : char* sztoa(size_t value, char* str, int base){

$LN11:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 287  : 
; 288  : 	if (base < 2 || base > 16)

	cmp	DWORD PTR base$[rsp], 2
	jl	SHORT $LN7@sztoa
	cmp	DWORD PTR base$[rsp], 16
	jle	SHORT $LN8@sztoa
$LN7@sztoa:

; 289  : 		return nullptr;

	xor	eax, eax
	jmp	$LN9@sztoa
$LN8@sztoa:

; 290  : 	unsigned int i = 0;

	mov	DWORD PTR i$[rsp], 0
$LN6@sztoa:

; 291  : 	do {
; 292  : 		str[++i] = chars[value%base];

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	eax, DWORD PTR i$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	movsxd	rcx, DWORD PTR base$[rsp]
	xor	edx, edx
	mov	rax, QWORD PTR value$[rsp]
	div	rcx
	mov	rax, rdx
	mov	rcx, QWORD PTR str$[rsp]
	mov	rdx, QWORD PTR chars
	movzx	eax, BYTE PTR [rdx+rax]
	mov	rdx, QWORD PTR tv67[rsp]
	mov	BYTE PTR [rcx+rdx], al

; 293  : 		value /= base;

	movsxd	rax, DWORD PTR base$[rsp]
	mov	QWORD PTR tv74[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR value$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	div	rcx
	mov	QWORD PTR value$[rsp], rax

; 294  : 	} while (value != 0);

	cmp	QWORD PTR value$[rsp], 0
	jne	SHORT $LN6@sztoa

; 295  : 	str[0] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR str$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 296  : 	for (unsigned int z = 0; z < i; ++z, --i)

	mov	DWORD PTR z$2[rsp], 0
	jmp	SHORT $LN3@sztoa
$LN2@sztoa:
	mov	eax, DWORD PTR z$2[rsp]
	inc	eax
	mov	DWORD PTR z$2[rsp], eax
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@sztoa:
	mov	eax, DWORD PTR i$[rsp]
	cmp	DWORD PTR z$2[rsp], eax
	jae	SHORT $LN1@sztoa

; 297  : 	{
; 298  : 		char tmp = str[z];

	mov	eax, DWORD PTR z$2[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tmp$1[rsp], al

; 299  : 		str[z] = str[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR z$2[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	mov	r8, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 300  : 		str[i] = tmp;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	movzx	edx, BYTE PTR tmp$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 301  : 	}

	jmp	SHORT $LN2@sztoa
$LN1@sztoa:

; 302  : 	return str;

	mov	rax, QWORD PTR str$[rsp]
$LN9@sztoa:

; 303  : }

	add	rsp, 40					; 00000028H
	ret	0
?sztoa@@YAPEAD_KPEADH@Z ENDP				; sztoa
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\aurora kernel\ldr\auldr\print.cpp
_TEXT	SEGMENT
o$ = 32
c$ = 36
ljust$ = 40
lzeroes$ = 41
width$ = 44
alt$ = 48
precision$ = 52
v$1 = 56
lmodifier$ = 60
dcnt$2 = 64
sign$ = 68
len$3 = 72
vl$ = 80
base$4 = 88
tmp$5 = 92
i$6 = 96
p$7 = 104
len$8 = 112
tv281 = 116
hexpfx$9 = 120
tv329 = 128
tv327 = 132
tv77 = 136
s$10 = 144
tv128 = 152
tv84 = 156
tv68 = 160
tv195 = 164
tv141 = 168
tv214 = 172
tv149 = 176
tv265 = 180
tv182 = 184
tv201 = 188
tv383 = 192
ch$11 = 196
tv375 = 200
tv376 = 204
tv292 = 208
digits$12 = 216
tv174 = 224
tv407 = 232
tv160 = 240
s$13 = 248
out$ = 272
fmt$ = 2336
?printf@@YAHPEA_WZZ PROC				; printf

; 9    : int printf(wchar_t *fmt, ...) {

$LN133:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 2328				; 00000918H

; 10   : 	va_list vl = (va_list)((uint8_t*)&fmt + sizeof(unsigned short *));

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR vl$[rsp], rax

; 11   : 
; 12   : 	unsigned short out[1024];
; 13   : 	int o = 0;

	mov	DWORD PTR o$[rsp], 0
$LN132@printf:
$LN131@printf:
$LN130@printf:
$LN129@printf:
$LN128@printf:
$LN115@printf:

; 14   : 	int c, sign, width, precision, lmodifier;
; 15   : 	unsigned char ljust, alt, lzeroes;
; 16   : 
; 17   : 	while (c = *fmt++) {

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv68[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv68[rsp], 0
	je	$LN114@printf

; 18   : 		if (c != '%' || *fmt == '%') {

	cmp	DWORD PTR c$[rsp], 37			; 00000025H
	jne	SHORT $LN112@printf
	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN113@printf
$LN112@printf:

; 19   : 			out[o++] = c;

	movsxd	rax, DWORD PTR o$[rsp]
	movzx	ecx, WORD PTR c$[rsp]
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 20   : 			fmt += (c == '%');

	cmp	DWORD PTR c$[rsp], 37			; 00000025H
	jne	SHORT $LN118@printf
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN119@printf
$LN118@printf:
	mov	DWORD PTR tv77[rsp], 0
$LN119@printf:
	movsxd	rax, DWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR fmt$[rsp], rax

; 21   : 			continue;

	jmp	$LN115@printf
$LN113@printf:

; 22   : 		}
; 23   : 		if ((c = (uint8_t)*fmt++) == '\0')

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv84[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv84[rsp], 0
	jne	SHORT $LN111@printf

; 24   : 			return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN111@printf:

; 25   : 		ljust = alt = lzeroes = FALSE;

	mov	BYTE PTR lzeroes$[rsp], 0
	movzx	eax, BYTE PTR lzeroes$[rsp]
	mov	BYTE PTR alt$[rsp], al
	movzx	eax, BYTE PTR alt$[rsp]
	mov	BYTE PTR ljust$[rsp], al

; 26   : 		sign = 0;

	mov	DWORD PTR sign$[rsp], 0
$LN110@printf:

; 27   : 		for (;;) {
; 28   : 			if (c == '-'){

	cmp	DWORD PTR c$[rsp], 45			; 0000002dH
	jne	SHORT $LN108@printf

; 29   : 				ljust = TRUE;

	mov	BYTE PTR ljust$[rsp], 1

; 30   : 				lzeroes = FALSE;

	mov	BYTE PTR lzeroes$[rsp], 0
	jmp	SHORT $LN107@printf
$LN108@printf:

; 31   : 			}
; 32   : 			else if (c == '+')

	cmp	DWORD PTR c$[rsp], 43			; 0000002bH
	jne	SHORT $LN106@printf

; 33   : 				sign = '+';

	mov	DWORD PTR sign$[rsp], 43		; 0000002bH
	jmp	SHORT $LN105@printf
$LN106@printf:

; 34   : 			else if (c == ' ') {

	cmp	DWORD PTR c$[rsp], 32			; 00000020H
	jne	SHORT $LN104@printf

; 35   : 				if (!sign)

	cmp	DWORD PTR sign$[rsp], 0
	jne	SHORT $LN103@printf

; 36   : 					sign = ' ';

	mov	DWORD PTR sign$[rsp], 32		; 00000020H
$LN103@printf:

; 37   : 			}

	jmp	SHORT $LN102@printf
$LN104@printf:

; 38   : 			else if (c == '#')

	cmp	DWORD PTR c$[rsp], 35			; 00000023H
	jne	SHORT $LN101@printf

; 39   : 				alt = TRUE;

	mov	BYTE PTR alt$[rsp], 1
	jmp	SHORT $LN100@printf
$LN101@printf:

; 40   : 			else if (c == '0') {

	cmp	DWORD PTR c$[rsp], 48			; 00000030H
	jne	SHORT $LN99@printf

; 41   : 				if (!ljust)

	movzx	eax, BYTE PTR ljust$[rsp]
	test	eax, eax
	jne	SHORT $LN98@printf

; 42   : 					lzeroes = TRUE;

	mov	BYTE PTR lzeroes$[rsp], 1
$LN98@printf:

; 43   : 			}
; 44   : 			else

	jmp	SHORT $LN97@printf
$LN99@printf:

; 45   : 				break;

	jmp	SHORT $LN109@printf
$LN97@printf:
$LN100@printf:
$LN102@printf:
$LN105@printf:
$LN107@printf:

; 46   : 
; 47   : 			if ((c = (uint8_t)*fmt++) == '\0')

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv128[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv128[rsp], 0
	jne	SHORT $LN96@printf

; 48   : 				return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN96@printf:

; 49   : 		}

	jmp	$LN110@printf
$LN109@printf:

; 50   : 
; 51   : 		width = -1;

	mov	DWORD PTR width$[rsp], -1

; 52   : 		if (is_digit(c)) {

	mov	ecx, DWORD PTR c$[rsp]
	call	?is_digit@@YAHH@Z			; is_digit
	test	eax, eax
	je	SHORT $LN95@printf

; 53   : 			width = 0;

	mov	DWORD PTR width$[rsp], 0
$LN94@printf:

; 54   : 			while (is_digit(c)) {

	mov	ecx, DWORD PTR c$[rsp]
	call	?is_digit@@YAHH@Z			; is_digit
	test	eax, eax
	je	SHORT $LN93@printf

; 55   : 				width = width * 10 + (c - '0');

	imul	eax, DWORD PTR width$[rsp], 10
	mov	ecx, DWORD PTR c$[rsp]
	lea	eax, DWORD PTR [rax+rcx-48]
	mov	DWORD PTR width$[rsp], eax

; 56   : 				if ((c = (uint8_t)*fmt++) == '\0')

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv141[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv141[rsp], 0
	jne	SHORT $LN92@printf

; 57   : 					return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN92@printf:

; 58   : 			}

	jmp	SHORT $LN94@printf
$LN93@printf:

; 59   : 		}
; 60   : 		else if (c == '*') {

	jmp	SHORT $LN91@printf
$LN95@printf:
	cmp	DWORD PTR c$[rsp], 42			; 0000002aH
	jne	SHORT $LN90@printf

; 61   : 			width = *(int *)vl; vl += sizeof(int);

	mov	rax, QWORD PTR vl$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR width$[rsp], eax
	mov	rax, QWORD PTR vl$[rsp]
	add	rax, 4
	mov	QWORD PTR vl$[rsp], rax

; 62   : 			if (width < 0) {

	cmp	DWORD PTR width$[rsp], 0
	jge	SHORT $LN89@printf

; 63   : 				ljust = TRUE;

	mov	BYTE PTR ljust$[rsp], 1

; 64   : 				lzeroes = FALSE;

	mov	BYTE PTR lzeroes$[rsp], 0

; 65   : 				width = -width;

	mov	eax, DWORD PTR width$[rsp]
	neg	eax
	mov	DWORD PTR width$[rsp], eax
$LN89@printf:

; 66   : 			}
; 67   : 			if ((c = *fmt++) == '\0')

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv149[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv149[rsp], 0
	jne	SHORT $LN88@printf

; 68   : 				return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN88@printf:
$LN90@printf:
$LN91@printf:

; 69   : 		}
; 70   : 
; 71   : 		if (c == '['){

	cmp	DWORD PTR c$[rsp], 91			; 0000005bH
	jne	SHORT $LN87@printf

; 72   : 			if (o > 0) {

	cmp	DWORD PTR o$[rsp], 0
	jle	SHORT $LN86@printf

; 73   : 				out[o] = 0;

	movsxd	rax, DWORD PTR o$[rsp]
	xor	ecx, ecx
	mov	WORD PTR out$[rsp+rax*2], cx

; 74   : 				aulib_get_system_table()->ConOut->OutputString(aulib_get_system_table()->ConOut, out);

	call	?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ ; aulib_get_system_table
	mov	QWORD PTR tv160[rsp], rax
	call	?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ ; aulib_get_system_table
	mov	rax, QWORD PTR [rax+64]
	lea	rdx, QWORD PTR out$[rsp]
	mov	rcx, QWORD PTR tv160[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	call	QWORD PTR [rax+8]

; 75   : 				o = 0;

	mov	DWORD PTR o$[rsp], 0
$LN86@printf:

; 76   : 			}
; 77   : 			/**uint32 attr = *(unsigned long*)vl;
; 78   : 			vl += sizeof(unsigned long);**/
; 79   : 			aulib_set_text_attrib(0x000000F0, 0x0000000F); //attr &

	mov	edx, 15
	mov	ecx, 240				; 000000f0H
	call	?aulib_set_text_attrib@@YAXHH@Z		; aulib_set_text_attrib

; 80   : 			continue;

	jmp	$LN128@printf
$LN87@printf:

; 81   : 		}
; 82   : 		//restore the default text attribute
; 83   : 		if (c == ']') {

	cmp	DWORD PTR c$[rsp], 93			; 0000005dH
	jne	SHORT $LN85@printf

; 84   : 			if (o >0) {

	cmp	DWORD PTR o$[rsp], 0
	jle	SHORT $LN84@printf

; 85   : 				out[o] = 0;

	movsxd	rax, DWORD PTR o$[rsp]
	xor	ecx, ecx
	mov	WORD PTR out$[rsp+rax*2], cx

; 86   : 				aulib_get_system_table()->ConOut->OutputString(aulib_get_system_table()->ConOut, out);

	call	?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ ; aulib_get_system_table
	mov	QWORD PTR tv174[rsp], rax
	call	?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ ; aulib_get_system_table
	mov	rax, QWORD PTR [rax+64]
	lea	rdx, QWORD PTR out$[rsp]
	mov	rcx, QWORD PTR tv174[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	call	QWORD PTR [rax+8]

; 87   : 				o = 0;

	mov	DWORD PTR o$[rsp], 0
$LN84@printf:

; 88   : 			}
; 89   : 			aulib_set_text_attrib(EFI_BACKGROUND_BLACK, EFI_LIGHTGRAY);

	mov	edx, 7
	xor	ecx, ecx
	call	?aulib_set_text_attrib@@YAXHH@Z		; aulib_set_text_attrib

; 90   : 			continue;

	jmp	$LN129@printf
$LN85@printf:

; 91   : 		}
; 92   : 
; 93   : 		precision = -1;

	mov	DWORD PTR precision$[rsp], -1

; 94   : 		if (c == '.') {

	cmp	DWORD PTR c$[rsp], 46			; 0000002eH
	jne	$LN83@printf

; 95   : 			if ((c = (uint8_t)*fmt++) == '\0')

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv182[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv182[rsp], 0
	jne	SHORT $LN82@printf

; 96   : 				return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN82@printf:

; 97   : 			precision = 0;

	mov	DWORD PTR precision$[rsp], 0

; 98   : 			lzeroes = FALSE;

	mov	BYTE PTR lzeroes$[rsp], 0

; 99   : 			if (is_digit(c)) {

	mov	ecx, DWORD PTR c$[rsp]
	call	?is_digit@@YAHH@Z			; is_digit
	test	eax, eax
	je	SHORT $LN81@printf
$LN80@printf:

; 100  : 				while (is_digit(c)){

	mov	ecx, DWORD PTR c$[rsp]
	call	?is_digit@@YAHH@Z			; is_digit
	test	eax, eax
	je	SHORT $LN79@printf

; 101  : 					precision = precision * 10 + (c - '0');

	imul	eax, DWORD PTR precision$[rsp], 10
	mov	ecx, DWORD PTR c$[rsp]
	lea	eax, DWORD PTR [rax+rcx-48]
	mov	DWORD PTR precision$[rsp], eax

; 102  : 					if ((c = (uint8_t)*fmt++) == '\0')

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv195[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv195[rsp], 0
	jne	SHORT $LN78@printf

; 103  : 						return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN78@printf:

; 104  : 				}

	jmp	SHORT $LN80@printf
$LN79@printf:

; 105  : 			}
; 106  : 			else if (c == '*'){

	jmp	SHORT $LN77@printf
$LN81@printf:
	cmp	DWORD PTR c$[rsp], 42			; 0000002aH
	jne	SHORT $LN76@printf

; 107  : 				precision = *(int *)vl; vl += sizeof(int);

	mov	rax, QWORD PTR vl$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR precision$[rsp], eax
	mov	rax, QWORD PTR vl$[rsp]
	add	rax, 4
	mov	QWORD PTR vl$[rsp], rax

; 108  : 				if ((c = *fmt++) == '\0')

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv201[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv201[rsp], 0
	jne	SHORT $LN75@printf

; 109  : 					return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN75@printf:
$LN76@printf:
$LN77@printf:
$LN83@printf:

; 110  : 			}
; 111  : 		}
; 112  : 
; 113  : 		lmodifier = 0;

	mov	DWORD PTR lmodifier$[rsp], 0

; 114  : 		if (c == 'h') {

	cmp	DWORD PTR c$[rsp], 104			; 00000068H
	jne	SHORT $LN74@printf

; 115  : 			if (*fmt == 'h') {

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 104				; 00000068H
	jne	SHORT $LN73@printf

; 116  : 				fmt++;

	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax

; 117  : 				lmodifier = 'H';

	mov	DWORD PTR lmodifier$[rsp], 72		; 00000048H

; 118  : 			}
; 119  : 			else

	jmp	SHORT $LN72@printf
$LN73@printf:

; 120  : 				lmodifier = c;

	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR lmodifier$[rsp], eax
$LN72@printf:
	jmp	SHORT $LN71@printf
$LN74@printf:

; 121  : 		}
; 122  : 		else if (wstrchr(L"jzt", c))

	mov	edx, DWORD PTR c$[rsp]
	lea	rcx, OFFSET FLAT:$SG13292
	call	?wstrchr@@YAPEA_WPEA_WH@Z		; wstrchr
	test	rax, rax
	je	SHORT $LN70@printf

; 123  : 			lmodifier = c;

	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR lmodifier$[rsp], eax
$LN70@printf:
$LN71@printf:

; 124  : 		if (lmodifier)

	cmp	DWORD PTR lmodifier$[rsp], 0
	je	SHORT $LN69@printf

; 125  : 		if ((c = (uint8_t)*fmt++) == '\0')

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv214[rsp], eax
	mov	rax, QWORD PTR fmt$[rsp]
	add	rax, 2
	mov	QWORD PTR fmt$[rsp], rax
	cmp	DWORD PTR tv214[rsp], 0
	jne	SHORT $LN68@printf

; 126  : 			return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN68@printf:
$LN69@printf:

; 127  : 
; 128  : 		if (c == 'i')

	cmp	DWORD PTR c$[rsp], 105			; 00000069H
	jne	SHORT $LN67@printf

; 129  : 			c = 'd';

	mov	DWORD PTR c$[rsp], 100			; 00000064H
$LN67@printf:

; 130  : 		if (!wstrchr(L"douxXcsp", c))

	mov	edx, DWORD PTR c$[rsp]
	lea	rcx, OFFSET FLAT:$SG13298
	call	?wstrchr@@YAPEA_WPEA_WH@Z		; wstrchr
	test	rax, rax
	jne	SHORT $LN66@printf

; 131  : 			return -1;

	mov	eax, -1
	jmp	$LN116@printf
$LN66@printf:

; 132  : 
; 133  : 		if (c == 'c') {

	cmp	DWORD PTR c$[rsp], 99			; 00000063H
	jne	$LN65@printf

; 134  : 			int ch = (uint8_t)* (int *)vl; vl += sizeof(int);

	mov	rax, QWORD PTR vl$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR ch$11[rsp], eax
	mov	rax, QWORD PTR vl$[rsp]
	add	rax, 4
	mov	QWORD PTR vl$[rsp], rax

; 135  : 			if (!ljust)

	movzx	eax, BYTE PTR ljust$[rsp]
	test	eax, eax
	jne	SHORT $LN64@printf
$LN63@printf:

; 136  : 			while (width > 1) {

	cmp	DWORD PTR width$[rsp], 1
	jle	SHORT $LN62@printf

; 137  : 				out[o++] = ' ';

	movsxd	rax, DWORD PTR o$[rsp]
	mov	ecx, 32					; 00000020H
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 138  : 				width--;

	mov	eax, DWORD PTR width$[rsp]
	dec	eax
	mov	DWORD PTR width$[rsp], eax

; 139  : 			}

	jmp	SHORT $LN63@printf
$LN62@printf:
$LN64@printf:

; 140  : 			out[o++] = ch;

	movsxd	rax, DWORD PTR o$[rsp]
	movzx	ecx, WORD PTR ch$11[rsp]
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 141  : 
; 142  : 			if (ljust)

	movzx	eax, BYTE PTR ljust$[rsp]
	test	eax, eax
	je	SHORT $LN61@printf
$LN60@printf:

; 143  : 			while (width > 1) {

	cmp	DWORD PTR width$[rsp], 1
	jle	SHORT $LN59@printf

; 144  : 				out[o++] = ' ';

	movsxd	rax, DWORD PTR o$[rsp]
	mov	ecx, 32					; 00000020H
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 145  : 				width--;

	mov	eax, DWORD PTR width$[rsp]
	dec	eax
	mov	DWORD PTR width$[rsp], eax

; 146  : 			}

	jmp	SHORT $LN60@printf
$LN59@printf:
$LN61@printf:

; 147  : 			continue;

	jmp	$LN130@printf
	jmp	$LN58@printf
$LN65@printf:

; 148  : 		}
; 149  : 		else if (c == 's') {

	cmp	DWORD PTR c$[rsp], 115			; 00000073H
	jne	$LN57@printf

; 150  : 			int len, i;
; 151  : 			wchar_t *s = *(wchar_t**)vl; vl += sizeof(wchar_t *);

	mov	rax, QWORD PTR vl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR s$10[rsp], rax
	mov	rax, QWORD PTR vl$[rsp]
	add	rax, 8
	mov	QWORD PTR vl$[rsp], rax

; 152  : 
; 153  : 			if (precision < 0)

	cmp	DWORD PTR precision$[rsp], 0
	jge	SHORT $LN56@printf

; 154  : 				len = wstrlen(s);

	mov	rcx, QWORD PTR s$10[rsp]
	call	?wstrlen@@YAHPEA_W@Z			; wstrlen
	mov	DWORD PTR len$3[rsp], eax

; 155  : 			else {

	jmp	SHORT $LN55@printf
$LN56@printf:

; 156  : 				len = 0;

	mov	DWORD PTR len$3[rsp], 0
$LN54@printf:

; 157  : 				while (len < precision)

	mov	eax, DWORD PTR precision$[rsp]
	cmp	DWORD PTR len$3[rsp], eax
	jge	SHORT $LN53@printf

; 158  : 				if (s[len]) len++;

	movsxd	rax, DWORD PTR len$3[rsp]
	mov	rcx, QWORD PTR s$10[rsp]
	movzx	eax, WORD PTR [rcx+rax*2]
	test	eax, eax
	je	SHORT $LN52@printf
	mov	eax, DWORD PTR len$3[rsp]
	inc	eax
	mov	DWORD PTR len$3[rsp], eax

; 159  : 				else break;

	jmp	SHORT $LN51@printf
$LN52@printf:
	jmp	SHORT $LN53@printf
$LN51@printf:
	jmp	SHORT $LN54@printf
$LN53@printf:
$LN55@printf:

; 160  : 			}
; 161  : 
; 162  : 			if (!ljust) {

	movzx	eax, BYTE PTR ljust$[rsp]
	test	eax, eax
	jne	SHORT $LN50@printf
$LN49@printf:

; 163  : 				while (width > len) {

	mov	eax, DWORD PTR len$3[rsp]
	cmp	DWORD PTR width$[rsp], eax
	jle	SHORT $LN48@printf

; 164  : 					out[o++] = ' ';

	movsxd	rax, DWORD PTR o$[rsp]
	mov	ecx, 32					; 00000020H
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 165  : 					width--;

	mov	eax, DWORD PTR width$[rsp]
	dec	eax
	mov	DWORD PTR width$[rsp], eax

; 166  : 				}

	jmp	SHORT $LN49@printf
$LN48@printf:
$LN50@printf:

; 167  : 			}
; 168  : 
; 169  : 			i = len;

	mov	eax, DWORD PTR len$3[rsp]
	mov	DWORD PTR i$6[rsp], eax
$LN47@printf:

; 170  : 			while (i--)

	mov	eax, DWORD PTR i$6[rsp]
	mov	DWORD PTR tv265[rsp], eax
	mov	eax, DWORD PTR i$6[rsp]
	dec	eax
	mov	DWORD PTR i$6[rsp], eax
	cmp	DWORD PTR tv265[rsp], 0
	je	SHORT $LN46@printf

; 171  : 				out[o++] = *s++;

	movsxd	rax, DWORD PTR o$[rsp]
	mov	rcx, QWORD PTR s$10[rsp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax
	mov	rax, QWORD PTR s$10[rsp]
	add	rax, 2
	mov	QWORD PTR s$10[rsp], rax
	jmp	SHORT $LN47@printf
$LN46@printf:

; 172  : 
; 173  : 			if (ljust) {

	movzx	eax, BYTE PTR ljust$[rsp]
	test	eax, eax
	je	SHORT $LN45@printf
$LN44@printf:

; 174  : 				while (width > len) {

	mov	eax, DWORD PTR len$3[rsp]
	cmp	DWORD PTR width$[rsp], eax
	jle	SHORT $LN43@printf

; 175  : 					out[o++] = ' ';

	movsxd	rax, DWORD PTR o$[rsp]
	mov	ecx, 32					; 00000020H
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 176  : 					width--;

	mov	eax, DWORD PTR width$[rsp]
	dec	eax
	mov	DWORD PTR width$[rsp], eax

; 177  : 				}

	jmp	SHORT $LN44@printf
$LN43@printf:
$LN45@printf:

; 178  : 			}
; 179  : 			continue;

	jmp	$LN131@printf

; 180  : 		}
; 181  : 		else {

	jmp	$LN42@printf
$LN57@printf:

; 182  : 			unsigned v = *(unsigned *)vl, tmp;

	mov	rax, QWORD PTR vl$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR v$1[rsp], eax

; 183  : 			char s[11];
; 184  : 			char *p = s + sizeof(s);

	lea	rax, QWORD PTR s$13[rsp+11]
	mov	QWORD PTR p$7[rsp], rax

; 185  : 			unsigned base = (c == 'p') ? 16 : 10;

	cmp	DWORD PTR c$[rsp], 112			; 00000070H
	jne	SHORT $LN120@printf
	mov	DWORD PTR tv281[rsp], 16
	jmp	SHORT $LN121@printf
$LN120@printf:
	mov	DWORD PTR tv281[rsp], 10
$LN121@printf:
	mov	eax, DWORD PTR tv281[rsp]
	mov	DWORD PTR base$4[rsp], eax

; 186  : 			char  *digits = "0123456789abcdef";

	lea	rax, OFFSET FLAT:$SG13345
	mov	QWORD PTR digits$12[rsp], rax

; 187  : 			char *hexpfx = (char*)NULL;

	mov	QWORD PTR hexpfx$9[rsp], 0

; 188  : 			int dcnt;
; 189  : 			int len;
; 190  : 			vl += sizeof(unsigned);

	mov	rax, QWORD PTR vl$[rsp]
	add	rax, 4
	mov	QWORD PTR vl$[rsp], rax

; 191  : 
; 192  : 			if (c == 'o')

	cmp	DWORD PTR c$[rsp], 111			; 0000006fH
	jne	SHORT $LN41@printf

; 193  : 				base = 8;

	mov	DWORD PTR base$4[rsp], 8
	jmp	SHORT $LN40@printf
$LN41@printf:

; 194  : 			else if (to_upper(c) == 'X') {

	mov	ecx, DWORD PTR c$[rsp]
	call	?to_upper@@YAHH@Z			; to_upper
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN39@printf

; 195  : 				base = 16;

	mov	DWORD PTR base$4[rsp], 16

; 196  : 				if (c == 'X')

	cmp	DWORD PTR c$[rsp], 88			; 00000058H
	jne	SHORT $LN38@printf

; 197  : 					digits = "0123456789ABCDEF";

	lea	rax, OFFSET FLAT:$SG13356
	mov	QWORD PTR digits$12[rsp], rax
$LN38@printf:

; 198  : 				if (alt && v)

	movzx	eax, BYTE PTR alt$[rsp]
	test	eax, eax
	je	SHORT $LN37@printf
	cmp	DWORD PTR v$1[rsp], 0
	je	SHORT $LN37@printf

; 199  : 					hexpfx = (c == 'X') ? "0X" : "0x";

	cmp	DWORD PTR c$[rsp], 88			; 00000058H
	jne	SHORT $LN122@printf
	lea	rax, OFFSET FLAT:$SG13358
	mov	QWORD PTR tv292[rsp], rax
	jmp	SHORT $LN123@printf
$LN122@printf:
	lea	rax, OFFSET FLAT:$SG13359
	mov	QWORD PTR tv292[rsp], rax
$LN123@printf:
	mov	rax, QWORD PTR tv292[rsp]
	mov	QWORD PTR hexpfx$9[rsp], rax
$LN37@printf:
$LN39@printf:
$LN40@printf:

; 200  : 			}
; 201  : 
; 202  : 			if (c != 'd') {

	cmp	DWORD PTR c$[rsp], 100			; 00000064H
	je	SHORT $LN36@printf

; 203  : 				if (lmodifier == 'H')

	cmp	DWORD PTR lmodifier$[rsp], 72		; 00000048H
	jne	SHORT $LN35@printf

; 204  : 					v = (uint8_t)v;

	movzx	eax, BYTE PTR v$1[rsp]
	mov	DWORD PTR v$1[rsp], eax
	jmp	SHORT $LN34@printf
$LN35@printf:

; 205  : 				else if (lmodifier = 'h')

	mov	DWORD PTR lmodifier$[rsp], 104		; 00000068H
	cmp	DWORD PTR lmodifier$[rsp], 0
	je	SHORT $LN33@printf

; 206  : 					v = (unsigned short)v;

	movzx	eax, WORD PTR v$1[rsp]
	mov	DWORD PTR v$1[rsp], eax
$LN33@printf:
$LN34@printf:

; 207  : 				sign = 0;

	mov	DWORD PTR sign$[rsp], 0

; 208  : 			}
; 209  : 			else {

	jmp	SHORT $LN32@printf
$LN36@printf:

; 210  : 				if (lmodifier = 'H')

	mov	DWORD PTR lmodifier$[rsp], 72		; 00000048H
	cmp	DWORD PTR lmodifier$[rsp], 0
	je	SHORT $LN31@printf

; 211  : 					v = (signed char)v;

	movsx	eax, BYTE PTR v$1[rsp]
	mov	DWORD PTR v$1[rsp], eax
	jmp	SHORT $LN30@printf
$LN31@printf:

; 212  : 				else if (lmodifier == 'h')

	cmp	DWORD PTR lmodifier$[rsp], 104		; 00000068H
	jne	SHORT $LN29@printf

; 213  : 					v = (short)v;

	movsx	eax, WORD PTR v$1[rsp]
	mov	DWORD PTR v$1[rsp], eax
$LN29@printf:
$LN30@printf:

; 214  : 				if ((int)v < 0) {

	cmp	DWORD PTR v$1[rsp], 0
	jge	SHORT $LN28@printf

; 215  : 					v = -v;

	mov	eax, DWORD PTR v$1[rsp]
	neg	eax
	mov	DWORD PTR v$1[rsp], eax

; 216  : 					sign = '-';

	mov	DWORD PTR sign$[rsp], 45		; 0000002dH
$LN28@printf:
$LN32@printf:

; 217  : 				}
; 218  : 			}
; 219  : 
; 220  : 
; 221  : 			tmp = v;

	mov	eax, DWORD PTR v$1[rsp]
	mov	DWORD PTR tmp$5[rsp], eax
$LN27@printf:

; 222  : 			do{
; 223  : 				*--p = digits[tmp % base];

	mov	rax, QWORD PTR p$7[rsp]
	dec	rax
	mov	QWORD PTR p$7[rsp], rax
	xor	edx, edx
	mov	eax, DWORD PTR tmp$5[rsp]
	div	DWORD PTR base$4[rsp]
	mov	eax, edx
	mov	eax, eax
	mov	rcx, QWORD PTR p$7[rsp]
	mov	rdx, QWORD PTR digits$12[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al

; 224  : 				tmp /= base;

	xor	edx, edx
	mov	eax, DWORD PTR tmp$5[rsp]
	div	DWORD PTR base$4[rsp]
	mov	DWORD PTR tmp$5[rsp], eax

; 225  : 			} while (tmp);

	cmp	DWORD PTR tmp$5[rsp], 0
	jne	SHORT $LN27@printf

; 226  : 			dcnt = s + sizeof(s)-p;

	lea	rax, QWORD PTR s$13[rsp+11]
	sub	rax, QWORD PTR p$7[rsp]
	mov	DWORD PTR dcnt$2[rsp], eax

; 227  : 
; 228  : 			if (precision < 0)

	cmp	DWORD PTR precision$[rsp], 0
	jge	SHORT $LN24@printf

; 229  : 				precision = 1;

	mov	DWORD PTR precision$[rsp], 1
	jmp	SHORT $LN23@printf
$LN24@printf:

; 230  : 			else if ((v == 0) && (precision == 0))

	cmp	DWORD PTR v$1[rsp], 0
	jne	SHORT $LN22@printf
	cmp	DWORD PTR precision$[rsp], 0
	jne	SHORT $LN22@printf

; 231  : 				dcnt = 0;

	mov	DWORD PTR dcnt$2[rsp], 0
$LN22@printf:
$LN23@printf:

; 232  : 
; 233  : 			if (alt && (c == 'o'))

	movzx	eax, BYTE PTR alt$[rsp]
	test	eax, eax
	je	SHORT $LN21@printf
	cmp	DWORD PTR c$[rsp], 111			; 0000006fH
	jne	SHORT $LN21@printf

; 234  : 			if (((v == 0) && (precision == 0)) || (v && (precision <= dcnt)))

	cmp	DWORD PTR v$1[rsp], 0
	jne	SHORT $LN18@printf
	cmp	DWORD PTR precision$[rsp], 0
	je	SHORT $LN19@printf
$LN18@printf:
	cmp	DWORD PTR v$1[rsp], 0
	je	SHORT $LN20@printf
	mov	eax, DWORD PTR dcnt$2[rsp]
	cmp	DWORD PTR precision$[rsp], eax
	jg	SHORT $LN20@printf
$LN19@printf:

; 235  : 				precision = dcnt + 1;

	mov	eax, DWORD PTR dcnt$2[rsp]
	inc	eax
	mov	DWORD PTR precision$[rsp], eax
$LN20@printf:
$LN21@printf:

; 236  : 
; 237  : 			if (precision < dcnt)

	mov	eax, DWORD PTR dcnt$2[rsp]
	cmp	DWORD PTR precision$[rsp], eax
	jge	SHORT $LN17@printf

; 238  : 				precision = dcnt;

	mov	eax, DWORD PTR dcnt$2[rsp]
	mov	DWORD PTR precision$[rsp], eax
$LN17@printf:

; 239  : 
; 240  : 
; 241  : 			len = (sign != 0) + (hexpfx != NULL) * 2 + precision;

	cmp	DWORD PTR sign$[rsp], 0
	je	SHORT $LN124@printf
	mov	DWORD PTR tv327[rsp], 1
	jmp	SHORT $LN125@printf
$LN124@printf:
	mov	DWORD PTR tv327[rsp], 0
$LN125@printf:
	cmp	QWORD PTR hexpfx$9[rsp], 0
	je	SHORT $LN126@printf
	mov	DWORD PTR tv329[rsp], 1
	jmp	SHORT $LN127@printf
$LN126@printf:
	mov	DWORD PTR tv329[rsp], 0
$LN127@printf:
	mov	eax, DWORD PTR tv327[rsp]
	mov	ecx, DWORD PTR tv329[rsp]
	lea	eax, DWORD PTR [rax+rcx*2]
	add	eax, DWORD PTR precision$[rsp]
	mov	DWORD PTR len$8[rsp], eax

; 242  : 
; 243  : 			if (!ljust && !lzeroes)

	movzx	eax, BYTE PTR ljust$[rsp]
	test	eax, eax
	jne	SHORT $LN16@printf
	movzx	eax, BYTE PTR lzeroes$[rsp]
	test	eax, eax
	jne	SHORT $LN16@printf
$LN15@printf:

; 244  : 			while (width > len) {

	mov	eax, DWORD PTR len$8[rsp]
	cmp	DWORD PTR width$[rsp], eax
	jle	SHORT $LN14@printf

; 245  : 				out[o++] = ' ';

	movsxd	rax, DWORD PTR o$[rsp]
	mov	ecx, 32					; 00000020H
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 246  : 				width--;

	mov	eax, DWORD PTR width$[rsp]
	dec	eax
	mov	DWORD PTR width$[rsp], eax

; 247  : 			}

	jmp	SHORT $LN15@printf
$LN14@printf:
$LN16@printf:

; 248  : 
; 249  : 			if (sign)

	cmp	DWORD PTR sign$[rsp], 0
	je	SHORT $LN13@printf

; 250  : 				out[o++] = sign;

	movsxd	rax, DWORD PTR o$[rsp]
	movzx	ecx, WORD PTR sign$[rsp]
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax
	jmp	SHORT $LN12@printf
$LN13@printf:

; 251  : 			else if (hexpfx) {

	cmp	QWORD PTR hexpfx$9[rsp], 0
	je	SHORT $LN11@printf

; 252  : 				out[o++] = hexpfx[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hexpfx$9[rsp]
	movsx	ax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR o$[rsp]
	mov	WORD PTR out$[rsp+rcx*2], ax
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 253  : 				out[o++] = hexpfx[1];

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hexpfx$9[rsp]
	movsx	ax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR o$[rsp]
	mov	WORD PTR out$[rsp+rcx*2], ax
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax
$LN11@printf:
$LN12@printf:

; 254  : 			}
; 255  : 
; 256  : 			if (!ljust && lzeroes)

	movzx	eax, BYTE PTR ljust$[rsp]
	test	eax, eax
	jne	SHORT $LN10@printf
	movzx	eax, BYTE PTR lzeroes$[rsp]
	test	eax, eax
	je	SHORT $LN10@printf
$LN9@printf:

; 257  : 			while (width > len) {

	mov	eax, DWORD PTR len$8[rsp]
	cmp	DWORD PTR width$[rsp], eax
	jle	SHORT $LN8@printf

; 258  : 				out[o++] = '0';

	movsxd	rax, DWORD PTR o$[rsp]
	mov	ecx, 48					; 00000030H
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 259  : 				width--;

	mov	eax, DWORD PTR width$[rsp]
	dec	eax
	mov	DWORD PTR width$[rsp], eax

; 260  : 			}

	jmp	SHORT $LN9@printf
$LN8@printf:
$LN10@printf:
$LN7@printf:

; 261  : 
; 262  : 			while (precision-- > dcnt)

	mov	eax, DWORD PTR precision$[rsp]
	mov	DWORD PTR tv375[rsp], eax
	mov	eax, DWORD PTR dcnt$2[rsp]
	mov	DWORD PTR tv376[rsp], eax
	mov	eax, DWORD PTR precision$[rsp]
	dec	eax
	mov	DWORD PTR precision$[rsp], eax
	mov	eax, DWORD PTR tv376[rsp]
	cmp	DWORD PTR tv375[rsp], eax
	jle	SHORT $LN6@printf

; 263  : 				out[o++] = '0';

	movsxd	rax, DWORD PTR o$[rsp]
	mov	ecx, 48					; 00000030H
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax
	jmp	SHORT $LN7@printf
$LN6@printf:
$LN5@printf:

; 264  : 
; 265  : 			while (dcnt--)

	mov	eax, DWORD PTR dcnt$2[rsp]
	mov	DWORD PTR tv383[rsp], eax
	mov	eax, DWORD PTR dcnt$2[rsp]
	dec	eax
	mov	DWORD PTR dcnt$2[rsp], eax
	cmp	DWORD PTR tv383[rsp], 0
	je	SHORT $LN4@printf

; 266  : 				out[o++] = *p++;

	mov	rax, QWORD PTR p$7[rsp]
	movsx	ax, BYTE PTR [rax]
	movsxd	rcx, DWORD PTR o$[rsp]
	mov	WORD PTR out$[rsp+rcx*2], ax
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax
	mov	rax, QWORD PTR p$7[rsp]
	inc	rax
	mov	QWORD PTR p$7[rsp], rax
	jmp	SHORT $LN5@printf
$LN4@printf:

; 267  : 
; 268  : 			if (ljust)

	movzx	eax, BYTE PTR ljust$[rsp]
	test	eax, eax
	je	SHORT $LN3@printf
$LN2@printf:

; 269  : 			while (width > len) {

	mov	eax, DWORD PTR len$8[rsp]
	cmp	DWORD PTR width$[rsp], eax
	jle	SHORT $LN1@printf

; 270  : 				out[o++] = ' ';

	movsxd	rax, DWORD PTR o$[rsp]
	mov	ecx, 32					; 00000020H
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 271  : 				width--;

	mov	eax, DWORD PTR width$[rsp]
	dec	eax
	mov	DWORD PTR width$[rsp], eax

; 272  : 			}

	jmp	SHORT $LN2@printf
$LN1@printf:
$LN3@printf:

; 273  : 
; 274  : 			continue;

	jmp	$LN132@printf
$LN42@printf:
$LN58@printf:

; 275  : 		}
; 276  : 	}

	jmp	$LN115@printf
$LN114@printf:

; 277  : 
; 278  : 	out[o++] = 0;

	movsxd	rax, DWORD PTR o$[rsp]
	xor	ecx, ecx
	mov	WORD PTR out$[rsp+rax*2], cx
	mov	eax, DWORD PTR o$[rsp]
	inc	eax
	mov	DWORD PTR o$[rsp], eax

; 279  : 	aulib_get_system_table()->ConOut->OutputString(aulib_get_system_table()->ConOut, out);

	call	?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ ; aulib_get_system_table
	mov	QWORD PTR tv407[rsp], rax
	call	?aulib_get_system_table@@YAPEAUEFI_SYSTEM_TABLE@@XZ ; aulib_get_system_table
	mov	rax, QWORD PTR [rax+64]
	lea	rdx, QWORD PTR out$[rsp]
	mov	rcx, QWORD PTR tv407[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	call	QWORD PTR [rax+8]

; 280  : 	return 0;

	xor	eax, eax
$LN116@printf:

; 281  : }

	add	rsp, 2328				; 00000918H
	ret	0
?printf@@YAHPEA_WZZ ENDP				; printf
_TEXT	ENDS
END
