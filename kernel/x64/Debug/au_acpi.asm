; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?au_acpi@@3U_aurora_acpi_@@A			; au_acpi
_BSS	SEGMENT
?au_acpi@@3U_aurora_acpi_@@A DB 031H DUP (?)		; au_acpi
_BSS	ENDS
CONST	SEGMENT
$SG3264	DB	'FACP', 00H
	ORG $+3
$SG3265	DB	'FACP', 00H
	ORG $+3
$SG3269	DB	'APIC', 00H
	ORG $+3
$SG3270	DB	'APIC', 00H
CONST	ENDS
PUBLIC	?au_initialize_acpi@@YAHXZ			; au_initialize_acpi
PUBLIC	?au_acpi_get_num_core@@YAIXZ			; au_acpi_get_num_core
PUBLIC	??$raw_diff@U_acpi_apic_header_@@UacpiMadt@@@@YAHPEAU_acpi_apic_header_@@PEAUacpiMadt@@@Z ; raw_diff<_acpi_apic_header_,acpiMadt>
PUBLIC	??$raw_offset@PEAU_acpi_apic_header_@@PEAU1@@@YAPEAU_acpi_apic_header_@@PEAU0@H@Z ; raw_offset<_acpi_apic_header_ * __ptr64,_acpi_apic_header_ * __ptr64>
EXTRN	x86_64_phys_to_virt:PROC
EXTRN	?au_get_boot_info@@YAPEAU_AURORA_INFO_@@XZ:PROC	; au_get_boot_info
EXTRN	?strlen@@YA_KPEBD@Z:PROC			; strlen
EXTRN	?strncmp@@YAHPEBD0_K@Z:PROC			; strncmp
EXTRN	?strncpy@@YAPEADPEADPEBD_K@Z:PROC		; strncpy
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
pdata	SEGMENT
$pdata$?au_initialize_acpi@@YAHXZ DD imagerel $LN16
	DD	imagerel $LN16+508
	DD	imagerel $unwind$?au_initialize_acpi@@YAHXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?au_initialize_acpi@@YAHXZ DD 020701H
	DD	0110107H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\aurora kernel\kernel\include\stdint.h
;	COMDAT ??$raw_offset@PEAU_acpi_apic_header_@@PEAU1@@@YAPEAU_acpi_apic_header_@@PEAU0@H@Z
_TEXT	SEGMENT
p1$ = 8
offset$ = 16
??$raw_offset@PEAU_acpi_apic_header_@@PEAU1@@@YAPEAU_acpi_apic_header_@@PEAU0@H@Z PROC ; raw_offset<_acpi_apic_header_ * __ptr64,_acpi_apic_header_ * __ptr64>, COMDAT

; 203  : 	{

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 204  : 		return (T)((size_t)p1 + offset);

	movsxd	rax, DWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR p1$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 205  : 	};

	ret	0
??$raw_offset@PEAU_acpi_apic_header_@@PEAU1@@@YAPEAU_acpi_apic_header_@@PEAU0@H@Z ENDP ; raw_offset<_acpi_apic_header_ * __ptr64,_acpi_apic_header_ * __ptr64>
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\aurora kernel\kernel\include\stdint.h
;	COMDAT ??$raw_diff@U_acpi_apic_header_@@UacpiMadt@@@@YAHPEAU_acpi_apic_header_@@PEAUacpiMadt@@@Z
_TEXT	SEGMENT
p1$ = 8
p2$ = 16
??$raw_diff@U_acpi_apic_header_@@UacpiMadt@@@@YAHPEAU_acpi_apic_header_@@PEAUacpiMadt@@@Z PROC ; raw_diff<_acpi_apic_header_,acpiMadt>, COMDAT

; 199  : 	{

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 200  : 		return (intptr_t)p1 - (intptr_t)p2;

	mov	eax, DWORD PTR p2$[rsp]
	mov	ecx, DWORD PTR p1$[rsp]
	sub	ecx, eax
	mov	eax, ecx

; 201  : 	};

	ret	0
??$raw_diff@U_acpi_apic_header_@@UacpiMadt@@@@YAHPEAU_acpi_apic_header_@@PEAUacpiMadt@@@Z ENDP ; raw_diff<_acpi_apic_header_,acpiMadt>
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\aurora kernel\kernel\kdrivers\au_acpi.cpp
_TEXT	SEGMENT
?au_acpi_get_num_core@@YAIXZ PROC			; au_acpi_get_num_core

; 98   : 	return au_acpi.num_core;

	mov	eax, DWORD PTR ?au_acpi@@3U_aurora_acpi_@@A+45

; 99   : }

	ret	0
?au_acpi_get_num_core@@YAIXZ ENDP			; au_acpi_get_num_core
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\aurora kernel\kernel\kdrivers\au_acpi.cpp
_TEXT	SEGMENT
apic_header$1 = 32
sig$ = 40
tv154 = 48
header$ = 56
count$2 = 64
entries$ = 72
rsdt$ = 80
rsdp$ = 88
lapic$3 = 96
acpi_base$ = 104
xsdt$ = 112
ioapic$4 = 120
?au_initialize_acpi@@YAHXZ PROC				; au_initialize_acpi

; 45   : int au_initialize_acpi() {

$LN16:
	sub	rsp, 136				; 00000088H

; 46   : 	void* acpi_base = (void*)x86_64_phys_to_virt((uint64_t)au_get_boot_info()->acpi_table_pointer);

	call	?au_get_boot_info@@YAPEAU_AURORA_INFO_@@XZ ; au_get_boot_info
	mov	rcx, QWORD PTR [rax+66]
	call	x86_64_phys_to_virt
	mov	QWORD PTR acpi_base$[rsp], rax

; 47   : 	memset(&au_acpi, 0, sizeof(aurora_acpi));

	mov	r8d, 49					; 00000031H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?au_acpi@@3U_aurora_acpi_@@A ; au_acpi
	call	?memset@@YAXPEAXEI@Z			; memset

; 48   : 
; 49   : 	acpiRsdp *rsdp = (acpiRsdp*)acpi_base;

	mov	rax, QWORD PTR acpi_base$[rsp]
	mov	QWORD PTR rsdp$[rsp], rax

; 50   : 	acpiRsdt *rsdt = (acpiRsdt*)x86_64_phys_to_virt((uint64_t)rsdp->rsdtAddr);

	mov	rax, QWORD PTR rsdp$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, eax
	call	x86_64_phys_to_virt
	mov	QWORD PTR rsdt$[rsp], rax

; 51   : 	acpiXsdt *xsdt = (acpiXsdt*)x86_64_phys_to_virt((uint64_t)rsdp->xsdtAddr);

	mov	rax, QWORD PTR rsdp$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	x86_64_phys_to_virt
	mov	QWORD PTR xsdt$[rsp], rax

; 52   : 	char sig[5];
; 53   : 
; 54   : 	int entries = (rsdt->header.length - sizeof(rsdt->header)) / 4;

	mov	rax, QWORD PTR rsdt$[rsp]
	mov	eax, DWORD PTR [rax+4]
	sub	rax, 36					; 00000024H
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	DWORD PTR entries$[rsp], eax

; 55   : 	acpiSysDescHeader *header = NULL;

	mov	QWORD PTR header$[rsp], 0

; 56   : 	
; 57   : 	for (size_t count = 0; count < entries; count++) {

	mov	QWORD PTR count$2[rsp], 0
	jmp	SHORT $LN13@au_initial
$LN12@au_initial:
	mov	rax, QWORD PTR count$2[rsp]
	inc	rax
	mov	QWORD PTR count$2[rsp], rax
$LN13@au_initial:
	movsxd	rax, DWORD PTR entries$[rsp]
	cmp	QWORD PTR count$2[rsp], rax
	jae	$LN11@au_initial

; 58   : 		header = (acpiSysDescHeader*)x86_64_phys_to_virt((uint64_t)rsdt->entry[count]);

	mov	rax, QWORD PTR rsdt$[rsp]
	mov	rcx, QWORD PTR count$2[rsp]
	mov	eax, DWORD PTR [rax+rcx*4+36]
	mov	ecx, eax
	call	x86_64_phys_to_virt
	mov	QWORD PTR header$[rsp], rax

; 59   : 		strncpy(sig, header->signature, 4);

	mov	rax, QWORD PTR header$[rsp]
	mov	r8d, 4
	mov	rdx, rax
	lea	rcx, QWORD PTR sig$[rsp]
	call	?strncpy@@YAPEADPEADPEBD_K@Z		; strncpy

; 60   : 		sig[4] = '\0';

	mov	eax, 1
	imul	rax, rax, 4
	mov	BYTE PTR sig$[rsp+rax], 0

; 61   : 
; 62   : 		if (!strncmp(sig, ACPI_SIG_FADT, strlen(ACPI_SIG_FADT))) {

	lea	rcx, OFFSET FLAT:$SG3264
	call	?strlen@@YA_KPEBD@Z			; strlen
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG3265
	lea	rcx, QWORD PTR sig$[rsp]
	call	?strncmp@@YAHPEBD0_K@Z			; strncmp
	test	eax, eax
	jne	SHORT $LN10@au_initial

; 63   : 			au_acpi.fadt = (acpiFadt*)header;

	mov	rax, QWORD PTR header$[rsp]
	mov	QWORD PTR ?au_acpi@@3U_aurora_acpi_@@A+9, rax
	jmp	$LN9@au_initial
$LN10@au_initial:

; 64   : 		}
; 65   : 
; 66   : 		else if (!strncmp(sig, ACPI_SIG_APIC, strlen("APIC"))) {

	lea	rcx, OFFSET FLAT:$SG3269
	call	?strlen@@YA_KPEBD@Z			; strlen
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG3270
	lea	rcx, QWORD PTR sig$[rsp]
	call	?strncmp@@YAHPEBD0_K@Z			; strncmp
	test	eax, eax
	jne	$LN8@au_initial

; 67   : 			au_acpi.madt = (acpiMadt*)header;

	mov	rax, QWORD PTR header$[rsp]
	mov	QWORD PTR ?au_acpi@@3U_aurora_acpi_@@A+1, rax

; 68   : 			
; 69   : 			acpiApicHeader *apic_header = (acpiApicHeader*)au_acpi.madt->entry;

	mov	rax, QWORD PTR ?au_acpi@@3U_aurora_acpi_@@A+1
	add	rax, 44					; 0000002cH
	mov	QWORD PTR apic_header$1[rsp], rax
$LN7@au_initial:

; 70   : 			while (raw_diff(apic_header, au_acpi.madt) < au_acpi.madt->header.length) {

	mov	rdx, QWORD PTR ?au_acpi@@3U_aurora_acpi_@@A+1
	mov	rcx, QWORD PTR apic_header$1[rsp]
	call	??$raw_diff@U_acpi_apic_header_@@UacpiMadt@@@@YAHPEAU_acpi_apic_header_@@PEAUacpiMadt@@@Z ; raw_diff<_acpi_apic_header_,acpiMadt>
	mov	rcx, QWORD PTR ?au_acpi@@3U_aurora_acpi_@@A+1
	cmp	eax, DWORD PTR [rcx+4]
	jae	SHORT $LN6@au_initial

; 71   : 				switch (apic_header->type) {

	mov	rax, QWORD PTR apic_header$1[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv154[rsp], al
	cmp	BYTE PTR tv154[rsp], 0
	je	SHORT $LN3@au_initial
	cmp	BYTE PTR tv154[rsp], 1
	je	SHORT $LN1@au_initial
	jmp	SHORT $LN4@au_initial
$LN3@au_initial:

; 72   :                     case ACPI_APICTYPE_LAPIC: {
; 73   : 						acpiLocalApic *lapic = (acpiLocalApic*)apic_header;

	mov	rax, QWORD PTR apic_header$1[rsp]
	mov	QWORD PTR lapic$3[rsp], rax

; 74   : 					//	au_get_boot_info()->auprint("LAPIC id -> %x, %x \n", lapic->lapicId, lapic->procId);
; 75   : 						if (lapic->procId != 0)

	mov	rax, QWORD PTR lapic$3[rsp]
	movzx	eax, BYTE PTR [rax+2]
	test	eax, eax
	je	SHORT $LN2@au_initial

; 76   : 							au_acpi.num_core = lapic->procId;

	mov	rax, QWORD PTR lapic$3[rsp]
	movzx	eax, BYTE PTR [rax+2]
	mov	DWORD PTR ?au_acpi@@3U_aurora_acpi_@@A+45, eax
$LN2@au_initial:

; 77   : 						 break;

	jmp	SHORT $LN4@au_initial
$LN1@au_initial:

; 78   : 					}
; 79   : 
; 80   : 					case ACPI_APICTYPE_IOAPIC: {
; 81   : 						acpiIoApic *ioapic = (acpiIoApic*)apic_header;

	mov	rax, QWORD PTR apic_header$1[rsp]
	mov	QWORD PTR ioapic$4[rsp], rax
$LN4@au_initial:

; 82   : 						break;
; 83   : 					}
; 84   : 				}
; 85   : 				apic_header = raw_offset <acpiApicHeader*>(apic_header, apic_header->length);

	mov	rax, QWORD PTR apic_header$1[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	edx, eax
	mov	rcx, QWORD PTR apic_header$1[rsp]
	call	??$raw_offset@PEAU_acpi_apic_header_@@PEAU1@@@YAPEAU_acpi_apic_header_@@PEAU0@H@Z ; raw_offset<_acpi_apic_header_ * __ptr64,_acpi_apic_header_ * __ptr64>
	mov	QWORD PTR apic_header$1[rsp], rax

; 86   : 			}

	jmp	$LN7@au_initial
$LN6@au_initial:
$LN8@au_initial:
$LN9@au_initial:

; 87   : 		}
; 88   : 	}

	jmp	$LN12@au_initial
$LN11@au_initial:

; 89   : 
; 90   : 	return 0;

	xor	eax, eax

; 91   : }

	add	rsp, 136				; 00000088H
	ret	0
?au_initialize_acpi@@YAHXZ ENDP				; au_initialize_acpi
_TEXT	ENDS
END
